; eXtended Genesis Music v2.0 (XGM) Z80 driver - Stephane Dallongeville @2022
;
; XGM driver is a music driver developed specifically for the Sega Megadrive/Genesis system.
; The XGM v2 driver has be developed to replace the previous XGM v1.0 driver, mainly to reduce music data space, improve PCM latency and
; add important missing features as envelop support and (if possible) FM/PSG SFX.
;
; As the previous XGM driver, it runs at 100% on the Z80 CPU and left the 68000 free for others tasks.
; It has been designed to keep CPU decoding resource reasonnable and provide small data size (about half the size of original XGM and about 1/3 of VGM file).
; It supports both FM and PSG chip and allow up to 3 PCM channels (8 bits signed) with adjustable playback rate up to ~13.3 Khz.
; PCM samples does not have any size limitation, the only restriction is that they should have their address and size aligned to 64 bytes (6 lower bit address not used).
; These 3 PCM channels are obtained by software mixing in the FM DAC in replacement of the 6th FM channel so at best you can have 5FM + 3PCM + 4PSG = 12 channels.
;
; The PCM playback rate can be modified from ~2Khz to ~13.3Khz but it's recommended to keep the original value (13.3 Khz) as all PCM channels share the same playback rate.
; Example of possible playback playback rate:
;  - 13.3 Khz
;  - 10.65 Khz
;  - 8.87 KHz
;  - 7.6 KHz
;  - 6.65 KHz
;  - 5.9 Khz
;  - ...
;
; Note that it's possible to enable half speed PCM playback:
; For instance if PCM playback rate is set to 13.3 Khz, then you can play PCM at full rate (13.3 Khz) or half rate (13.3 / 2 = 6.65 Khz)
; This feature allows to limit ROM usage for samples which don't need high playback rate.
; PCM can be 4bit ADPCM compressed or 8bit RAW, also they can be looped from a loop point (64 bytes aligned).
;
; The driver supports playing SFX through PCM channels, note that normally channel 0 is reserved for music so prefer channel 1 or channel 2 for SFX.
; Ideally the driver would also support FM and PSG SFX.
;
; Allowing a maximum of 13.3Khz PCM playback mean we have ~269 cycles per sample output which consist of:
; - handle PCM sync
; - read 4 samples from the rom and mix them into the write ring buffer
; - read 1 sample from read ring buffer and output it to the DAC
; - handle loop
; - unpack XGM data / parse and execute XGM commands / handle extern commands
;
; PCM output already cost a huge 87 cycles leaving only about 182 cycles for others tasks :'(
;
; BASE YM frequency:
;   NTSC: 7670453/144 = 53267 Hz
;   PAL:  7600489/144 = 52781 Hz
;
; Timer A is used for sample playback: PCM clock = base_FM_clock / (1023 - TimerA)
;  By defaut we set Timer A = 1019
;  - NTSC: 53267 / (1023-1019) = 53267 / 4 = ~13317 Hz
;  - PAL: 52781 / (1023-1019) = 52781 / 4 = ~13195 Hz
;  So we assume it to be ~13300 Hz (pitch get a bit lower on PAL system but we don't care)
;  Using 1020 for timer A would allow 17755 Hz PCM --> too high for driver playback so max is 13300 Hz.
;  - PCM sample rate can be modified (by changing timer A setting) from ~2Khz to ~13.3Khz :
;    1018 = ~10650 Hz; 1017 = ~8870 Hz; 1016 = ~7600 Hz; 1015 = ~6650 Hz; 1014 = ~5900 Hz; 1013 = ~5320 Hz
;  - allow half speed playback for PCM: 13300 Hz / 6650 Hz (copy twice on mix buffer for ~7Khz)
;
; register usage
; --------------
; HL  = sample source (in ROM)
; DE  = write buffer / XGM buffer
; BC  = counter
; B   = $80 (used for overflow and sample unsign)
; IXL = $27
; IXH = timer A reset write
; IY  = free usage
; HL' = YMPORT0
; DE' = YMPORT1
; BC' = read buffer

; ###########################      define      ##############################

            INCLUDE "z80_def.i80"   ; basic definitions


; ###########################       var        ##############################

XGM_PLAY_SFT    EQU     6           ; XGM music play command bit
XGM_RESUME_SFT  EQU     5           ; XGM music resume command bit
XGM_PAUSE_SFT   EQU     4           ; XGM music pause command bit

                                    ; COMMAND b0 = play PCM0   STATUS b0 = PCM0 playing
                                    ; COMMAND b1 = play PCM1   STATUS b1 = PCM1 playing
                                    ; COMMAND b2 = play PCM2   STATUS b2 = PCM2 playing
                                    ; COMMAND b3 = play PCM3   STATUS b3 = PCM3 playing
                                    ; COMMAND b4 = stop XGM
                                    ; COMMAND b5 = resume XGM
                                    ; COMMAND b6 = play XGM    STATUS b6 = XGM playing

XGM_ARG_A   EQU     PARAMS+$00      ; XGM address (bit 0 --> bit 23)

PCM0_ARG_P  EQU     PARAMS+$04      ; priority (0 to 15)
PCM0_ARG_ID EQU     PARAMS+$05      ; PCM id (0 to 255)
PCM1_ARG_P  EQU     PARAMS+$06      ; priority (0 to 15)
PCM1_ARG_ID EQU     PARAMS+$07      ; PCM id (0 to 255)
PCM2_ARG_P  EQU     PARAMS+$08      ; priority (0 to 15)
PCM2_ARG_ID EQU     PARAMS+$09      ; PCM id (0 to 255)
PCM3_ARG_P  EQU     PARAMS+$0A      ; priority (0 to 15)
PCM3_ARG_ID EQU     PARAMS+$0B      ; PCM id (0 to 255)

PCM_ARG_P   EQU     PCM0_ARG_P
PCM_ARG_ID  EQU     PCM0_ARG_ID

LOOP_ARG    EQU     PARAMS+$0C      ; number of loop (0 = 255 loop)
PROTECT_ARG EQU     PARAMS+$0D      ; set to 1 from 68k during DMA (in vblank period)
PENDING_FRM EQU     PARAMS+$0E      ; contains number of XGM frame to process
                                    ; to prevent Z80 accessing 68k BUS

Z80_ACCESS  EQU     PARAMS+$0F      ; Z80 is accessing command (reading / writing)

PCM0_PRIO   EQU     PARAMS+$10      ; PCM0 internal priority
PCM0_ADDR   EQU     PARAMS+$12      ; PCM0 internal addr (bit8 --> bit23)
PCM0_LEN    EQU     PARAMS+$14      ; PCM0 internal len (bit8 --> bit23)
PCM1_PRIO   EQU     PARAMS+$18      ; PCM1 internal priority
PCM1_ADDR   EQU     PARAMS+$1A      ; PCM1 internal addr (bit8 --> bit23)
PCM1_LEN    EQU     PARAMS+$1C      ; PCM1 internal len (bit8 --> bit23)
PCM2_PRIO   EQU     PARAMS+$20      ; PCM2 internal priority
PCM2_ADDR   EQU     PARAMS+$22      ; PCM2 internal addr (bit8 --> bit23)
PCM2_LEN    EQU     PARAMS+$24      ; PCM2 internal len (bit8 --> bit23)
PCM3_PRIO   EQU     PARAMS+$28      ; PCM3 internal priority
PCM3_ADDR   EQU     PARAMS+$2A      ; PCM3 internal addr (bit8 --> bit23)
PCM3_LEN    EQU     PARAMS+$2C      ; PCM3 internal len (bit8 --> bit23)

PCM_PRIO    EQU     PCM0_PRIO
PCM_ADDR    EQU     PCM0_ADDR
PCM_LEN     EQU     PCM0_LEN

XGM_ADDR    EQU     PARAMS+$30      ; XGM internal addr (bit0 --> bit23)

WRITEBUF    EQU     PARAMS+$34      ; PCM write buffer pointer (bit8 --> bit9)
READBUF     EQU     PARAMS+$36      ; PCM read buffer pointer (bit8 --> bit9)

REM_LOOP    EQU     PARAMS+$38      ; remaining loop (0 = 255)

YM_RR_SAV   EQU     PARAMS+$40      ; YM RR save (4 slots * 6 channels)
PSG_ENV_SAV EQU     PARAMS+$58      ; PSG env save (4 channels)
YM_RR_OFF   EQU     PARAMS+$60      ; YM RR off (4 slots * 6 channels)
PSG_ENV_OFF EQU     PARAMS+$78      ; PSG env off (4 channels)

YM_2B_SAV   EQU     PARAMS+$5C      ; YM register $2B last write save
YM_2B_CNT   EQU     PARAMS+$5D      ; YM register $2B ON expiration

IDLE_LOOP   EQU     PARAMS+$7C      ; idle loop counter (XGM frame wait)
WAIT_LOOP   EQU     PARAMS+$7E      ; wait loop counter (DMA contention wait)

DEBUG_1     EQU     PARAMS+$80      ; debug
DEBUG_2     EQU     PARAMS+$81      ; debug
DEBUG_3     EQU     PARAMS+$82      ; debug
DEBUG_4     EQU     PARAMS+$83      ; debug
DEBUG_5     EQU     PARAMS+$84      ; debug
DEBUG_6     EQU     PARAMS+$85      ; debug
DEBUG_7     EQU     PARAMS+$86      ; debug
DEBUG_8     EQU     PARAMS+$87      ; debug
DEBUG_9     EQU     PARAMS+$88      ; debug
DEBUG_A     EQU     PARAMS+$89      ; debug
DEBUG_B     EQU     PARAMS+$8A      ; debug

ELAPSED     EQU     PARAMS+$90      ; elapsed frame since beginning of music (in frames), encoded on 24 bit

JUMP_TABLE  EQU     $1600           ; XGM command jump table (size = $100)
XGM_BUFFER  EQU     $1700           ; XGM music data buffer (size = $100)

PCM_BUFFER0 EQU     $1800           ; PCM buffer 0
PCM_BUFFER1 EQU     $1900           ; PCM buffer 1
PCM_BUFFER2 EQU     $1A00           ; PCM buffer 2
PCM_BUFFER3 EQU     $1B00           ; PCM buffer 3

PCM_BUFFER  EQU     PCM_BUFFER0     ; PCM buffer


ID_TABLE    EQU     $1C00           ; sample id table (size = $400)

STACK       EQU     JUMP_TABLE      ; stack pointer above buffer region ($1600 --> $15XX)


; ###########################      macro       ##############################

            INCLUDE "z80_mac.i80"  ; basic macros


; sampleOutput
; ------------
; 0x27         ->  IXL
; timer A res  ->  IXH
; YMPORT0      ->  HL'
; YMPORT1      ->  DE'
; read buffer  ->  BC' ->  read buffer
;
; wait until sample timer elapsed and output a sample to the DAC
; = 87+ cycles

            macro sampleOutput

            DI                      ; disable ints              ' 4     |
            EXX                     ;                           ' 4     | (8)

.wait
            LD      A, (HL)         ; A = YM status             ' 7     |
            RRA                     ; timer A overflow ?        ' 4     | 18 (26)
            JR      NC, .wait       ;                           ' 7     |

; it may be too fast for the YM (need 8 cycles between ADDR and VALUE)
; also check than IXH isn't transfered before IXL when doing 16 bit operation with the Z80
;            LD      (YMPORT0), IX   ; reset timer A             ' 20    | (46)

            LD      (HL), 0x27      ; timer register            ' 10    |
            LD      A, IXH          ; A = timer A res           ' 8     | 25 (51)
            LD      (DE), A         ; reset timer A             ' 7     |

            LD      A, (BC)         ; read sample from buffer   ' 7     |
            LD      (HL), 0x2A      ; DAC register              ' 10    |
            INC     C               ; increment read address    ' 4     | 28 (79)
            LD      (DE), A         ; play sample               ' 7     |

.done
            EXX                     ;                           ' 4     |
            EI                      ; enable ints               ' 4     | 8 (87)

            endm


; writePCM1
; ---------
; point to sample source (ROM)  ->  DE  ->  point to sample source (ROM)
; point to write buffer         ->  HL  ->  point to write buffer
; number of write remaining     ->  BC  ->  number of write remaining
;
; read 1 sample from rom and write them in output buffer
; = 19 cycles

            macro writePCM1

            LDI                     ; copy 1 sample             ' 16+3  | (19)

            endm


; writePCM4
; ---------
; point to sample source (ROM)  ->  DE  ->  point to sample source (ROM)
; point to write buffer         ->  HL  ->  point to write buffer
; number of write remaining     ->  BC  ->  number of write remaining
;
; read 4 samples from rom and write them in output buffer
; = 76 cycles

            macro writePCM4

            writePCMNorm            ; write 4 samples           ' 19
            writePCMNorm            ;                           ' 19
            writePCMNorm            ;                           ' 19
            writePCMNorm            ;                           ' 19

            endm


; writePCM2HalfSpeed
; ------------------
; point to sample source (ROM)  ->  DE  ->  point to sample source (ROM)
; point to write buffer         ->  HL  ->  point to write buffer
;
; read 1 sample from rom and write it twice in output buffer (half speed playback speed)
; = 36 cycles

            macro writePCM2HalfSpeed

            LD      A, (DE)         ; read 1 sample from ROM    ' 7+3   |
            INC     E               ;                           ' 4     | (14)

            LD      (HL), A         ; 1st write                 ' 7     |
            INC     L               ;                           ' 4     |
            LD      (HL), A         ; 2nd write                 ' 7     | 22 (36)
            INC     L               ;                           ' 4     |

            endm


; writePCM8HalfSpeed
; ------------------
; point to sample source (ROM)  ->  DE  ->  point to sample source (ROM)
; point to write buffer         ->  HL  ->  point to write buffer
;
; read 4 samples from rom and write them twice in output buffer (half speed playback speed)
; = 144 cycles

            macro writePCM8HalfSpeed

            writePCM2HalfSpeed      ; write 8 samples           ' 36
            writePCM2HalfSpeed      ;                           ' 36
            writePCM2HalfSpeed      ;                           ' 36
            writePCM2HalfSpeed      ;                           ' 36

            endm


; mixPCM1
; -------
; point to sample source (ROM)  ->  DE  ->  point to sample source (ROM)
; point to write buffer         ->  HL  ->  point to write buffer
; $80 ->  C
;
; read 1 sample and mix it in output buffer
; = 42 cycles (+11 when overflow)

            macro mixPCM1

            LD      A, (DE)         ; read 1 sample from ROM    ' 7+3   |
            INC     E               ;                           ' 4     | (14)

            ADD     (HL)            ; mix with write buffer     ' 7     |
            JP      PO, .ok         ; check overflow            ' 10    | 17 (31)

            LD      A, C            ; fix overflow              ' 4     |
            ADC     $FF             ; A = $7F/$80               ' 7     | +11

.ok
            LD      (HL), A         ; store it in write buffer  ' 7     |
            INC     L               ;                           ' 4     | 11 (42)

            endm                    ;                           ' 42 (+11)


; mixPCM4
; -------
; point to sample source (ROM)  ->  DE  ->  point to sample source (ROM)
; point to write buffer         ->  HL  ->  point to write buffer
; $80 ->  C
;
; read 4 samples and mix them in output buffer
; = 168 cycles (+44 max)

            macro mixPCM4

            mixPCMNorm              ; mix 4 samples             ' 42
            mixPCMNorm              ;                           ' 42
            mixPCMNorm              ;                           ' 42
            mixPCMNorm              ;                           ' 42

            endm                    ;                           ' 168 (+44)


; mixPCM2HalfSpeed
; ----------------
; point to sample source (ROM)  ->  DE  ->  point to sample source (ROM)
; point to write buffer         ->  HL  ->  point to write buffer
; $80 ->  C
;
; read 1 sample and mix it twice in output buffer (half speed playback speed)
; = 80 cycles (+22 when overflow)

            macro mixPCM2HalfSpeed

            LD      A, (DE)         ; read 1 sample from ROM    ' 7+3   | (10)

            ADD     (HL)            ; 1st mix with write buffer ' 7     |
            JP      PO, .ok1        ; check overflow            ' 10    | 17 (27)

            LD      A, C            ; fix overflow              ' 4     |
            ADC     $FF             ; A = $7F/$80               ' 7     | +11

.ok1
            LD      (HL), A         ; store it                  ' 7     |
            INC     L               ;                           ' 4     | 11 (38)

            LD      A, (DE)         ; reload sample from ROM    ' 7+3   |
            INC     E               ; next                      ' 4     | 14 (52)

            ADD     (HL)            ; 2nd mix with write buffer ' 7     |
            JP      PO, .ok2        ; check overflow            ' 10    | 17 (69)

            LD      A, C            ; fix overflow              ' 4     |
            ADC     $FF             ; A = $7F/$80               ' 7     | +11

.ok2
            LD      (HL), A         ; store it                  ' 7     |
            INC     L               ;                           ' 4     | 11 (80)

            endm                    ;                           ' 80 (+22)


; mixPCM4HalfSpeed
; ----------------
; point to sample source (ROM)  ->  DE  ->  point to sample source (ROM)
; point to write buffer         ->  HL  ->  point to write buffer
; $80 ->  C
;
; read 2 samples and mix them twice in output buffer (half speed playback speed)
; = 160 cycles (+44 max)

            macro mixPCM4HalfSpeed

            mixPCM2HalfSpeed        ; mix 4 samples (HalfSpeed)     ' 80
            mixPCM2HalfSpeed        ;                               ' 80

            endm                    ;                               ' 160 (+44)


; mixPCMAndUnsign1
; ----------------
; point to sample source (ROM)  ->  DE  ->  point to sample source (ROM)
; point to write buffer         ->  HL  ->  point to write buffer
; $80 ->  C
;
; read 1 sample and mix it with output buffer, then unsign it
; = 46 (+11 when overflow)

            macro mixPCMAndUnsign1

            LD      A, (DE)         ; read 1 sample from ROM    ' 7+3   |
            INC     E               ;                           ' 4     | (14)

            ADD     (HL)            ; mix with write buffer     ' 7     |
            JP      PO, .ok         ; check overflow            ' 10    | 17 (31)

            LD      A, C            ; fix overflow              ' 4     |
            ADC     $FF             ; A = $7F/$80               ' 7     | +11

.ok
            ADD     C               ; unsign                    ' 4     |
            LD      (HL), A         ; store it in write buffer  ' 7     | 15 (46)
            INC     L               ;                           ' 4     |

            endm                    ;                           ' 46 (+11)


; mixPCMAndUnsign4
; ----------------
; point to sample source (ROM)  ->  DE  ->  point to sample source (ROM)
; point to write buffer         ->  HL  ->  point to write buffer
; $80 ->  C
;
; read 4 samples and mix them in output buffer, then unsign them
; = 184 (+44 when overflow)

            macro mixPCMAndUnsign4

            mixPCMAndUnsign1        ; mix and unsign 4 samples      ' 46
            mixPCMAndUnsign1        ;                               ' 46
            mixPCMAndUnsign1        ;                               ' 46
            mixPCMAndUnsign1        ;                               ' 46

            endm                    ;                               ' 184 (+44)


; mixPCMAndUnsign2HalfSpeed
; -------------------------
; point to sample source (ROM)  ->  DE  ->  point to sample source (ROM)
; point to write buffer         ->  HL  ->  point to write buffer
; $80 ->  C
;
; read 1 sample and mix it twice in output buffer (half speed playback speed), then unsign it
; = 88 cycles (+22 when overflow)

            macro mixPCMAndUnsign2HalfSpeed

            LD      A, (DE)         ; read 1 sample from ROM    ' 7+3   | (10)

            ADD     (HL)            ; 1st mix with write buffer ' 7     |
            JP      PO, .ok1        ; check overflow            ' 10    | 17 (27)

            LD      A, C            ; fix overflow              ' 4     |
            ADC     $FF             ; A = $7F/$80               ' 7     | +11

.ok1
            ADD     C               ; unsign                    ' 4     |
            LD      (HL), A         ; store it                  ' 7     | 15 (42)
            INC     L               ;                           ' 4     |

            LD      A, (DE)         ; reload sample from ROM    ' 7+3   |
            INC     E               ; next                      ' 4     | 14 (56)

            ADD     (HL)            ; 2nd mix with write buffer ' 7     |
            JP      PO, .ok2        ; check overflow            ' 10    | 17 (73)

            LD      A, C            ; fix overflow              ' 4     |
            ADC     $FF             ; A = $7F/$80               ' 7     | +11

.ok2
            ADD     C               ; unsign                    ' 4     |
            LD      (HL), A         ; store it                  ' 7     | 15 (88)
            INC     L               ;                           ' 4     |

            endm                    ;                           ' 88 (+22)


; mixPCMAndUnsign4HalfSpeed
; -------------------------
; point to sample source (ROM)  ->  DE  ->  point to sample source (ROM)
; point to write buffer         ->  HL  ->  point to write buffer
; $80 ->  C
;
; read 2 samples and mix them twice in output buffer (half speed playback speed), then unsign them
; = 176 cycles (+44 max)

            macro mixPCMAndUnsign4HalfSpeed

            mixPCMAndUnsign2HalfSpeed   ; mix and unsign 4 samples (HalfSpeed)  ' 88
            mixPCMAndUnsign2HalfSpeed   ;                                       ' 88

            endm                        ;                                       ' 176 (+44)


; waitYMReadyFast
; ---------------
; YMPORT0   ->  HL
;
; wait until YM ready
; = 22 cycles minimum (22 * X)

            macro waitYMReadyFast

.wait
            BIT     7, (HL)         ; test YM ready bit         ' 12    | (22)
            JP      NZ, .wait       ; wait while busy           ' 10    |

            endm


; waitYMReady
; -----------
; YMPORT0   ->  HL'
;
; wait until YM ready
; = 38 cycles minimum (16 + (22 * X))

            macro waitYMReady

            DI                      ;                           ' 4     |
            EXX                     ;                           ' 4     | (8)

.wait
            BIT     7, (HL)         ; test YM ready bit         ' 12    | 22 (30)
            JP      NZ, .wait       ; wait while busy           ' 10    |

            EXX                     ;                           ' 4     | 8 (38)
            EI                      ;                           ' 4     |

            endm


; ###########################       init       ##############################

            ORG     $0000

init
            DI                      ; disable ints
            LD      SP, STACK       ; setup stack
            IM      $01             ; set int mode 1
            XOR     A
            LD      (STATUS), A     ; driver not ready
            LD      (COMMAND), A    ; command cleared
            JP      start           ; jump to start


; ###########################       main       ##############################

            BLOCK   $0200-$

start

            LD      HL, PARAMS
            LD      A, $00
            LD      B, $40

cp_loop
            LD      (HL), A         ; clear parameters
            INC     HL
            DJNZ    cp_loop

            LD      HL, YM_RR_OFF
            LD      A, $FF
            LD      B, (6 * 4)

off_loop
            LD      (HL), A         ; clear off settings
            INC     HL
            DJNZ    off_loop

            LD      HL, PSG_ENV_OFF

            LD      (HL), $9F       ; PSG channel 0 off
            INC     HL
            LD      (HL), $BF       ; PSG channel 1 off
            INC     HL
            LD      (HL), $DF       ; PSG channel 2 off
            INC     HL
            LD      (HL), $FF       ; PSG channel 3 off

            LD      HL, YM_RR_OFF
            LD      DE, YM_RR_SAV
            LD      BC, (6 * 4) + 4
            LDIR                    ; copy off settings to sav settings

            LD      HL, PCM_BUFFER
            LD      A, $80
            LD      B, $00          ; for 256 * 4 bytes to clear

cb_loop
            LD      (HL), A         ; initialise buffers to silent
            INC     HL
            LD      (HL), A
            INC     HL
            LD      (HL), A
            INC     HL
            LD      (HL), A
            INC     HL
            DJNZ    cb_loop

            LD      A, $00

            LD      HL, YM_2B_SAV
            LD      (HL), A         ; DAC disabled by default
            LD      HL, YM_2B_CNT
            LD      (HL), A         ; DAC disabled by default

            LD      HL, MODIFYING_F
            LD      (HL), A         ; clear modifying variable flag
            LD      HL, PENDING_FRM
            LD      (HL), A         ; clear frame to process counter

            CALL    initDAC         ; prepare DAC for output

            LD      HL, PCM_BUFFER0 ; initialise write and read buffer
            LD      (WRITEBUF), HL
            LD      HL, PCM_BUFFER1
            LD      (READBUF), HL

            LD      BC, HL          ; BC' point to read buffer
            LD      HL, YMPORT0     ; HL' point to YMPORT0
            LD      DE, YMPORT1     ; DE' point to YMPORT1
            EXX

            stopChannel 0           ; stop all channels
            stopChannel 1
            stopChannel 2
            stopChannel 3

            LD      A, STATREADY
            LD      (STATUS), A     ; driver ready

main_loop

;    LD  A, (VCOUNTER)
;    LD  (DEBUG_1), A


; prepare XGM buffer
; ------------------

; $00


            sampleOutput                ;                       ' 36    | 36

            LD      DE, XGM_BUFFER      ; DE point to XGM buf   ' 10    |
            LD      A, (STATUS)         ; A = STATUS            ' 13    |
            BIT     XGM_PLAY_SFT, A     ; is XGM playing ?      ' 8     | 41 (77)
            JP      NZ, has_xgm         ; go to prepare buf     ' 10    |

            wait146                     ; sync                  ' 146   |
            XOR     A                   ; A = 0                 ' 4     | 160 (237)
            JP      end_prep_xgm        ; preparation done      ' 10    |

has_xgm
            LD      HL, (XGM_ADDR)      ; XGM addr (b0-b15)     ' 16    |
            LD      A, H                ; A = XGM addr (b8-b15) ' 4     |
            RLA                         ; CF = XGM addr b15     ' 4     | 146 (223)
            LD      A, (XGM_ADDR+2)     ; A = sample addr (H)   ' 13    |
            RLA                         ; sample addr (b22-b15) ' 4     |
            setBank_BC                  ; setBank               ' 105   |

            LD      A, H                ; save H                ' 4     |
            SET     7, H                ; HL = XGM addr bank    ' 8     |
            LD      B, $0               ; B = 0                 ' 7     | 30 (254-1)
            LD      C, (HL)             ; BC = bytes to process ' 7     |
            LD      H, A                ; restore H             ' 4     |

; $00+X
            sampleOutput                ;                       ' 36    | (36-1)

            LD      A, L                ; A = addr low          ' 4     |
            ADD     C                   ; compute new addr (L)  ' 4     |
            LD      (XGM_ADDR+0), A     ; store new addr (L)    ' 13    | 28 (63)
            JR      C, .split           ; carry --> separate    ' 7     |

.no_split
            wait104                     ; sync                  ' 104   | (167)

            SET     7, H                ; HL = XGM addr bank    ' 8     |
            INC     HL                  ; HL = start frame data ' 6     |
            XOR     A                   ; no second part        ' 4     |
            LD      IYH, A              ; IYH = sec part size   ' 8     | 44 (211)
            NOP                         ;                       ' 4     |
            DEC     C                   ; first part size = 0 ? ' 4     |
            JP      Z, .second_part     ; go to second part     ' 10    |

            wait12                      ; sync                  ' 12    | 22 (233)
            JP      .first_part_pre     ; start filling         ' 10    |

.split
            LD      IYH, A              ; IYH = sec part size   ' 8     |
            SUB     C                   ;                       ' 4     |
            NEG                         ;                       ' 8     | 34 (97)
            DEC     A                   ; A = (C - IYH) - 1     ' 4     |
            JP      NZ, .first_part_ok  ; not zero --> do it    ' 10    |

            LD      A, H                ; A = addr med (M)      ' 4     |
            ADD     $1                  ; inc with CF set       ' 7     |
            LD      (XGM_ADDR+1), A     ; store new addr (M)    ' 13    |
            LD      A, (XGM_ADDR+2)     ; load sample addr (H)  ' 13    |
            ADC     B                   ; inc                   ' 4     | 68 (164)
            LD      (XGM_ADDR+2), A     ; store sample addr (H) ' 13    |
            SET     7, H                ; HL = XGM addr bank    ' 8     |
            INC     HL                  ; HL = start frame data ' 6     |

            wait36                      ; sync                  ' 36    |
            JP      .second_part        ; go second part        ' 10    | 65 (211)

.first_part_ok
            LD      C, A                ; C = first part size   ' 4     |
            LD      A, H                ; A = addr med (M)      ' 4     |
            ADD     $1                  ; inc with CF set       ' 7     |
            LD      (XGM_ADDR+1), A     ; store new addr (M)    ' 13    |
            LD      A, (XGM_ADDR+2)     ; load sample addr (H)  ' 13    | 72 (169)
            ADC     B                   ; inc                   ' 4     |
            LD      (XGM_ADDR+2), A     ; store sample addr (H) ' 13    |
            SET     7, H                ; HL = XGM addr bank    ' 8     |
            INC     HL                  ; HL = start frame data ' 6     |

            wait64                      ; sync                  ' 64    | (233)

.first_part_pre                         ;                       ' 233
            LD      A, 11               ; A = block fill size   ' 7     |
            CP      C                   ; C < block size        ' 4     | 21 (254)
            JP      NC, .first_part_end ; go to last bytes      ' 10    |

.first_part
; $00+X
            sampleOutput                ;                       ' 36    | 36

            LDI                         ; fill XGM buffer       ' 16+1  |
            LDI                         ; 11 bytes at once      ' 16+1  |
            LDI                         ;                       ' 16+1  |
            LDI                         ;                       ' 16+1  |
            LDI                         ;                       ' 16+1  |
            LDI                         ;                       ' 16+1  | 187 (223)
            LDI                         ;                       ' 16+1  |
            LDI                         ;                       ' 16+1  |
            LDI                         ;                       ' 16+1  |
            LDI                         ;                       ' 16+1  |
            LDI                         ;                       ' 16+1  |

            wait10                      ; sync                  ' 10    |
            LD      A, 11               ; A = block fill size   ' 7     |
            CP      C                   ; remaining > 11        ' 4     | 31 (254)
            JP      C, .first_part      ; continu block fill    ' 10    |

.first_part_end
; $00+X
            sampleOutput                ;                       ' 36    | 36

            LDI                         ; fill XGM buffer       ' 16+1  |
            JP      PO, .fst_part_d0    ;                       ' 10    | 27 (63)
            LDI                         ;                       ' 16+1  |
            JP      PO, .fst_part_d1    ;                       ' 10    | 27 (90)
            LDI                         ;                       ' 16+1  |
            JP      PO, .fst_part_d2    ;                       ' 10    | 27 (117)
            LDI                         ;                       ' 16+1  |
            JP      PO, .fst_part_d3    ;                       ' 10    | 27 (144)
            LDI                         ;                       ' 16+1  |
            JP      PO, .fst_part_d4    ;                       ' 10    | 27 (171)
            LDI                         ;                       ' 16+1  |
            JP      PO, .fst_part_d5    ;                       ' 10    | 27 (198)

            wait56                      ; sync                  ' 56    | (254)

; $00+X
            sampleOutput                ;                       ' 36    | 36

            LDI                         ; fill XGM buffer       ' 16+1  |
            JP      PO, .fst_part_d0    ;                       ' 10    | 27 (63)
            LDI                         ;                       ' 16+1  |
            JP      PO, .fst_part_d1    ;                       ' 10    | 27 (90)
            LDI                         ;                       ' 16+1  |
            JP      PO, .fst_part_d2    ;                       ' 10    | 27 (117)
            LDI                         ;                       ' 16+1  |
            JP      PO, .fst_part_d3    ;                       ' 10    | 27 (144)
            LDI                         ;                       ' 16+1  |
            JP      PO, .fst_part_d4    ;                       ' 10    | 27 (171)
            LDI                         ;                       ' 16+1  |
            JP      .fst_part_d5        ;                       ' 10    | 27 (198)

.fst_part_d0
            wait27                      ; sync                  ' 27    | (90)
.fst_part_d1
            wait27                      ; sync                  ' 27    | (117)
.fst_part_d2
            wait27                      ; sync                  ' 27    | (144)
.fst_part_d3
            wait27                      ; sync                  ' 27    | (171)
.fst_part_d4
            wait27                      ; sync                  ' 27    | (198)
.fst_part_d5
            wait13                      ; sync                  ' 13    | (211)

.second_part                            ;                       ' 211
            NOP                         ; sync                  ' 4
            LD      A, IYH              ; A = second part size  ' 8     |
            OR      A                   ;                       ' 4     | 26 (237)
            JP      Z, end_prep_xgm     ; done                  ' 10    |

            wait17                      ; sync                  ' 17    | 254

; $00+X
            sampleOutput                ;                       ' 36    | 36

            LD      HL, (XGM_ADDR)      ; XGM addr (b0-b15)     ' 16    |
            LD      A, H                ; A = XGM addr (b8-b15) ' 4     |
            RLA                         ; CF = XGM addr b15     ' 4     | 146 (182)
            LD      A, (XGM_ADDR+2)     ; A = sample addr (H)   ' 13    |
            RLA                         ; sample addr (b22-b15) ' 4     |
            setBank_BC                  ; setBank               ' 105   |

            SET     7, H                ; HL = XGM addr bank    ' 8     | 15 (197)
            LD      L, 0                ;                       ' 7     |

            wait21                      ; sync                  ' 21    | (218)

            LD      B, 0                ; B = 0                 ' 7     |
            LD      C, IYH              ; BC = second part size ' 8     |
            LD      A, 11               ; A = block fill size   ' 7     | 36 (254)
            CP      C                   ; C < block size        ' 4     |
            JP      NC, .sec_part_end   ; go to last bytes      ' 10    |

; $00+X
.sec_part_loop
            sampleOutput                ;                       ' 36    | 36

            LDI                         ; fill XGM buffer       ' 16+1  |
            LDI                         ; 11 bytes at once      ' 16+1  |
            LDI                         ;                       ' 16+1  |
            LDI                         ;                       ' 16+1  |
            LDI                         ;                       ' 16+1  |
            LDI                         ;                       ' 16+1  | 187 (223)
            LDI                         ;                       ' 16+1  |
            LDI                         ;                       ' 16+1  |
            LDI                         ;                       ' 16+1  |
            LDI                         ;                       ' 16+1  |
            LDI                         ;                       ' 16+1  |

            wait10                      ; sync                  ' 10    |
            LD      A, 11               ; A = block fill size   ' 7     |
            CP      C                   ; remaining > 11        ' 4     | 31 (254)
            JP      C, .sec_part_loop   ; continu block fill    ' 10    |

.sec_part_end
; $00+X
            sampleOutput                ;                       ' 36    | 36

            LDI                         ; fill XGM buffer       ' 16+1  |
            JP      PO, .sec_part_d0    ;                       ' 10    | 27 (63)
            LDI                         ;                       ' 16+1  |
            JP      PO, .sec_part_d1    ;                       ' 10    | 27 (90)
            LDI                         ;                       ' 16+1  |
            JP      PO, .sec_part_d2    ;                       ' 10    | 27 (117)
            LDI                         ;                       ' 16+1  |
            JP      PO, .sec_part_d3    ;                       ' 10    | 27 (144)
            LDI                         ;                       ' 16+1  |
            JP      PO, .sec_part_d4    ;                       ' 10    | 27 (171)
            LDI                         ;                       ' 16+1  |
            JP      PO, .sec_part_d5    ;                       ' 10    | 27 (198)

            wait56                      ; sync                  ' 56    | (254)

; $00+X
            sampleOutput                ;                       ' 36    | 36

            LDI                         ; fill XGM buffer       ' 16+1  |
            JP      PO, .sec_part_d0    ;                       ' 10    | 27 (63)
            LDI                         ;                       ' 16+1  |
            JP      PO, .sec_part_d1    ;                       ' 10    | 27 (90)
            LDI                         ;                       ' 16+1  |
            JP      PO, .sec_part_d2    ;                       ' 10    | 27 (117)
            LDI                         ;                       ' 16+1  |
            JP      PO, .sec_part_d3    ;                       ' 10    | 27 (144)
            LDI                         ;                       ' 16+1  |
            JP      PO, .sec_part_d4    ;                       ' 10    | 27 (171)
            LDI                         ;                       ' 16+1  |
            JP      .sec_part_d5        ;                       ' 10    | 27 (198)

.sec_part_d0
            wait27                      ; sync                  '       | (90)
.sec_part_d1
            wait27                      ; sync                  '       | (117)
.sec_part_d2
            wait27                      ; sync                  '       | (144)
.sec_part_d3
            wait27                      ; sync                  '       | (171)
.sec_part_d4
            wait27                      ; sync                  '       | (198)
.sec_part_d5
            wait35                      ; sync                  ' 35    |
            XOR     A                   ; A = 0                 ' 4     | 39 (237)

end_prep_xgm                            ;                       ' 237
            LD      (DE), A             ; XGM buf end with 0    ' 7     |
            wait10                      ; sync                  ' 10    | 17 (254)


; XGM PREP DONE
; -------------

; $01+x
            sampleOutput                ;                       ' 36    | (36)

            LD      A, (STATUS)         ; A = STATUS            ' 13    |
            BIT     XGM_PLAY_SFT, A     ; XGM playing ?         ' 8     | 31 (67)
            JP      NZ, .inc            ; count elapsed         ' 10    |

            wait71                      ; sync                  ' 71    | 81 (148)
            JP      .noinc              ; preparation done      ' 10    |

.inc
            LD      HL, ELAPSED         ;                       ' 10    | (77)

            LD      A, (HL)             ;                       ' 7     |
            ADD     A, #1               ;                       ' 7     |
            LD      (HL), A             ;                       ' 7     |
            INC     L                   ;                       ' 4     |
            LD      A, (HL)             ;                       ' 7     |
            ADC     A, #0               ; inc elapsed frame     ' 7     | 71 (148)
            LD      (HL), A             ; (24 bit counter)      ' 7     |
            INC     L                   ;                       ' 4     |
            LD      A, (HL)             ;                       ' 7     |
            ADC     A, #0               ;                       ' 7     |
            LD      (HL), A             ;                       ' 7     |

.noinc
            wait60                      ; sync                  ' 60    | (208)

            LD      DE, (WRITEBUF)      ; DE = write buf        ' 20    |
            compareReadWrite            ; PCM buffer full ?     ' 16    | 46 (254)
            JP      Z, sync_frame       ; go to sync directly   ' 10    |

pcm_mix

; PCM channel 0
; -------------

            sampleOutputWait            ;                       ' 88+

            LD      HL, (PCM_ADDR+0)    ; HL = sample addr (HM) ' 16    |
            call    preparePCMBuffering ;                       ' 176   | (192)

            LD      BC, 60              ; prepare loop counter  ' 10    | 254

.loop_ch0
            sampleOutput

            writePCM6Norm               ;                       ' 114   |
            writePCMNorm                ;                       ' 19    | (133)

            sampleOutput

            writePCM6Norm               ;                       ' 114   |
            writePCMNorm                ;                       ' 19    | (133)

            sampleOutput

            writePCM6Norm               ;                       ' 114   |
            JP      PE, .loop_ch0       ;                       ' 10    | (124)

            sampleOutput

            writePCMNorm                ; 60                    ' 19    |
            writePCMNorm                ; 61                    ' 19    |
            writePCMNorm                ; 62                    ' 19    | (76)
            writePCMNorm                ; 63                    ' 19    |

            LD      HL, (PCM_ADDR+0)    ; HL = sample addr (HM) ' 16    |

            sampleOutputWait

            call    updateChannel       ; update channel data   ' 153   | 254


; PCM channel 1
; -------------

            sampleOutputWait            ;                       ' 88+

            LD      HL, (PCM_ADDR+8)    ; HL = sample addr (HM) ' 16    |
            call    preparePCMBuffering ;                       ' 176   | (192)

            LD      B, (60/6)           ; prepare loop counter  ' 7    | 254

.loop_ch1
            sampleOutput

            mixPCM3Norm                 ;                       ' 126   |

            sampleOutput

            mixPCM3Norm                 ;                       ' 126   |
            DJNZ    .loop_ch1           ;                       ' 10    | (136)

            sampleOutputWait

            mixPCM3Norm                 ;                       ' 126   |
            mixPCMNorm                  ;                       ' 126   |

            sampleOutput

            LD      HL, (PCM_ADDR+8)    ; HL = sample addr (HM) ' 16    |

            sampleOutputWait

            call    updateChannel       ; update channel data   ' 153   | 254


; PCM channel 2
; -------------

            sampleOutputWait            ;                       ' 88+

            LD      HL, (PCM_ADDR+(8*2)) ; HL = sample addr (HM) ' 16    |
            call    preparePCMBuffering ;                       ' 176   | (192)

            LD      B, (60/6)           ; prepare loop counter  ' 7    | 254

.loop_ch2
            sampleOutput

            mixPCM3Norm                 ;                       ' 126   |

            sampleOutput

            mixPCM3Norm                 ;                       ' 126   |
            DJNZ    .loop_ch2           ;                       ' 10    | (136)

            sampleOutputWait

            mixPCM3Norm                 ;                       ' 126   |
            mixPCMNorm                  ;                       ' 126   |

            sampleOutput

            LD      HL, (PCM_ADDR+8)    ; HL = sample addr (HM) ' 16    |

            sampleOutputWait

            call    updateChannel       ; update channel data   ' 153   | 254


; PCM channel 3
; -------------

; $7F+X
            sampleOutput                ;                       ' 36    |
            prepareChannelAlt 3         ;                       ' 176   | 254
            LD      BC, $1C80           ; prepare loop counter  ' 10    |
            wait32                      ; sync                  ' 32    |

; $80-$B7+X
.loop_ch3
            sampleOutput                ;                       ' 36    |
            readMixAndUnsign            ; mix/unsign 9 samples  ' 46    |
            readMixAndUnsign            ;                       ' 46    |
            readMixAndUnsign            ;                       ' 46    | 254+12
            readMixAndUnsign            ;                       ' 46    |
            readMixAndUnsign            ;                       ' 46    |

            sampleOutput                ; +12 --> late          ' 36    |
            readMixAndUnsign            ;                       ' 46    |
            readMixAndUnsign            ;                       ' 46    |
            readMixAndUnsign            ;                       ' 46    | 254
            readMixAndUnsign            ;                       ' 46    |
            wait8                       ; sync                  ' 8     |
            DEC     B                   ;                       ' 4     |
            JP      NZ, .loop_ch3       ;                       ' 10    |

; $B8+X
            sampleOutput                ;                       ' 36    |
            readMixAndUnsign            ;                       ' 46    |
            readMixAndUnsign            ;                       ' 46    | 254
            readMixAndUnsign            ;                       ' 46    |
            readMixAndUnsign            ;                       ' 46    |
            wait34                      ;                       ' 34    |

; $B9+X
            sampleOutput                ;                       ' 36    |
            updateChannelData 3         ; update channel data   ' 153   | 254
            wait65                      ; sync                  ' 65    |


;    LD  A, (VCOUNTER)
;    LD  (DEBUG_5), A

; next write buffer
; -----------------

; $BA+X
next_write_buf
            sampleOutput                ;                       ' 36    | 36

            LD      A, (STATUS)         ; A = (STATUS)          ' 13    |
            LD      HL, YMPORT0         ; HL point on YM port0  ' 10    |
            LD      (HL), $2B           ; register = DAC enable ' 10    | 54 (90)
            INC     L                   ; HL point on YM port1  ' 4     |
            AND     $0F                 ; PCM is playing ?      ' 7     |
            JP      NZ, .still_pcm      ;                       ' 10    |

            LD      A, (YM_2B_CNT)      ;                       ' 13    |
            OR      A                   ;                       ' 4     | 27 (117)
            JP      Z, .no_pcm          ; DAC enabled expired ? ' 10    |

            DEC     A                   ; decrement expiration  ' 4     |
            LD      (YM_2B_CNT), A      ;                       ' 13    |
            LD      A, $80              ; DAC enabled           ' 7     | 34 (151)
            JP      .set_dac            ; assume still PCM      ' 10    |

.still_pcm                              ;                       ' 90
            wait7                       ; sync                  ' 7     |
            LD      A, 3                ; set DAC ON expiration ' 7     | 27 (117)
            LD      (YM_2B_CNT), A      ; 4 frames to expire    ' 13    |

            wait17                      ; sync                  ' 17    |
            LD      A, $80              ; DAC enabled           ' 7     | 34 (151)
            JP      .set_dac            ; assume still PCM      ' 10    |

.no_pcm                                 ;                       ' 117
            wait21                      ; sync                  ' 21    |
            LD      A, (YM_2B_SAV)      ; use current DAC on    ' 13    | 34 (151)

.set_dac                                ;                       ' 151
            LD      (HL), A             ; set DAC enabled       ' 7     |
            DEC     L                   ; HL point on YM port0  ' 4     | 11 (162)

            EXX                         ;                       ' 4     |
            LD      A, B                ; A = read buffer high  ' 4     |
            LD      (READBUF+1), A      ; save current read buf ' 13    | 25 (187)
            EXX                         ;                       ' 4     |

            CP      D                   ; prepare DAC write     ' 4     |
            LD      (HL), 0x2A          ; write buf == read buf ' 10    | 24 (211)
            JP      Z, .continu_pcm     ; continu to fill pcm   ' 10    |

            INC     D                   ; inc write addr        ' 4     |
            RES     2, D                ; write addr &= 0x03FF  ' 8     | 42 (254-1)
            LD      (WRITEBUF), DE      ; save new write addr   ' 20    |
            JP      sync_frame          ;                       ' 10    |

.continu_pcm
            INC     D                   ; inc write addr        ' 4     |
            RES     2, D                ; write addr &= 0x03FF  ' 8     | 42 (254-1)
            LD      (WRITEBUF), DE      ; save new write addr   ' 20    |
            JP      pcm_mix             ; do pcm mix again      ' 10    |

; sync
; ----

; $BB+X
sync_frame                              ; DE point on write buf

;    LD  A, (VCOUNTER)
;    LD  (DEBUG_6), A

sync_frame_loop
            sampleOutput                ;                       ' 36    | (36)

            wait62                      ; sync                  ' 62    | (98)

            LD      HL, (IDLE_LOOP)     ;                       ' 16    |
            INC     HL                  ; increment idle loop   ' 6     | 38 (136)
            LD      (IDLE_LOOP), HL     ;                       ' 16    |

            LD      A, (PENDING_FRM)    ; A = frame to process  ' 13    |
            OR      A                   ; something to do ?     ' 4     | 27 (163)
            JP      NZ, .do_xgm         ; do the XGM frame      ' 10    |

            LD      A, (PROTECT_ARG)    ; get BUS protect state ' 13    |
            OR      A                   ; protecting ?          ' 4     | 27 (190)
            JP      NZ, .wait_dma       ; wait for it           ' 10    |

            EXX                         ;                       ' 4     |
            LD      A, B                ; A = read buffer high  ' 4     |
            LD      (READBUF+1), A      ; save current read buf ' 13    | 25 (215)
            EXX                         ;                       ' 4     |

            ADD     $1                  ;                       ' 7     |
            RES     2, A                ; read pos &= 0x03FF    ' 8     |
            CP      D                   ; pcm buffer empty ?    ' 4     | 29 (244)
            JP      Z, .do_pcm          ; fill pcm              ' 10    |

            JP      sync_frame_loop     ; wait for a frame      ' 10    | (254)

.wait_dma                               ;                       ' 190
            LD      HL, (WAIT_LOOP)     ;                       ' 16    |
            INC     HL                  ; increment wait loop   ' 6     | 38 (228)
            LD      (WAIT_LOOP), HL     ;                       ' 16    |

            wait16                      ; sync                  ' 16    |
            JP      sync_frame          ; wait for a frame      ' 10    | 26 (254)

.do_pcm                                 ;                       ' 244
            JP      pcm_mix             ; do pcm mix again      ' 10    | (254)

.do_xgm                                 ;                       ' 163
            wait81                      ; sync                  ' 81    |
            LD      DE, XGM_BUFFER      ; DE point to XGM buf   ' 10    | 91 (254)


;    LD  A, (VCOUNTER)
;    LD  (DEBUG_7), A

; execute XGM command
; -------------------

; $BC+X+Y
execute_xgm
            sampleOutput                ;                       ' 36    | (36)

            LD      A, (DE)             ; A = command           ' 7     |
            LD      (.ld_hl_xx + 1), A  ; set jump address      ' 13    |
            INC     E                   ; next command          ' 4     | 44 (80)
.ld_hl_xx                               ;                       '       |
            LD      HL, (JUMP_TABLE)    ; LD HL, (jt)           ' 16    |
            JP      (HL)                ;                       ' 4     |


; next frame command
; ------------------

com_next_frame                          ; 00                    ' 80
            JP      xgm_done            ; XGM frame done        ' 10    | (90)


; PSG command
; -----------

com_psg_tone_w0                         ; 10                    ' 80
            wait126                     ; sync                  ' 126   |
            LD      HL, PSGPORT         ; HL point on PSG port  ' 10    | 146 (226)
            JP      psg_tone_write0     ;                       ' 10    |

com_psg_tone_w1                         ; 11                    ' 80
            wait108                     ; sync                  ' 108   |
            LD      HL, PSGPORT         ; HL point on PSG port  ' 10    | 128 (208)
            JP      psg_tone_write1     ;                       ' 10    |

com_psg_tone_w2                         ; 12                    ' 80
            wait90                      ; sync                  ' 90    |
            LD      HL, PSGPORT         ; HL point on PSG port  ' 10    | 110 (190)
            JP      psg_tone_write2     ;                       ' 10    |

com_psg_tone_w3                         ; 13                    ' 80
            wait72                      ; sync                  ' 72    |
            LD      HL, PSGPORT         ; HL point on PSG port  ' 10    | 92 (172)
            JP      psg_tone_write3     ;                       ' 10    |

com_psg_tone_w4                         ; 14                    ' 80
            wait54                      ; sync                  ' 54    |
            LD      HL, PSGPORT         ; HL point on PSG port  ' 10    | 74 (154)
            JP      psg_tone_write4     ;                       ' 10    |

com_psg_tone_w5                         ; 15                    ' 80
            wait36                      ; sync                  ' 36    |
            LD      HL, PSGPORT         ; HL point on PSG port  ' 10    | 56 (136)
            JP      psg_tone_write5     ;                       ' 10    |

com_psg_tone_w6                         ; 16                    ' 80
            wait18                      ; sync                  ' 18    |
            LD      HL, PSGPORT         ; HL point on PSG port  ' 10    | 38 (118)
            JP      psg_tone_write6     ;                       ' 10    |

com_psg_tone_w7                         ; 17                    ' 80
            LD      HL, PSGPORT         ; HL point on PSG port  ' 10    | 20 (100)
            JP      psg_tone_write7     ;                       ' 10    |


psg_tone_write7                         ;                       ' 100
            LD      A, (DE)             ; A = PSG data          ' 7     |
            INC     E                   ; next data             ' 4     | 18 (118)
            LD      (HL), A             ; write to PSG          ' 7     |

psg_tone_write6
            LD      A, (DE)             ; A = PSG data          ' 7     |
            INC     E                   ; next data             ' 4     | 18 (136)
            LD      (HL), A             ; write to PSG          ' 7     |

psg_tone_write5
            LD      A, (DE)             ; A = PSG data          ' 7     |
            INC     E                   ; next data             ' 4     | 18 (154)
            LD      (HL), A             ; write to PSG          ' 7     |

psg_tone_write4
            LD      A, (DE)             ; A = PSG data          ' 7     |
            INC     E                   ; next data             ' 4     | 18 (172)
            LD      (HL), A             ; write to PSG          ' 7     |

psg_tone_write3
            LD      A, (DE)             ; A = PSG data          ' 7     |
            INC     E                   ; next data             ' 4     | 18 (190)
            LD      (HL), A             ; write to PSG          ' 7     |

psg_tone_write2
            LD      A, (DE)             ; A = PSG data          ' 7     |
            INC     E                   ; next data             ' 4     | 18 (208)
            LD      (HL), A             ; write to PSG          ' 7     |

psg_tone_write1
            LD      A, (DE)             ; A = PSG data          ' 7     |
            INC     E                   ; next data             ' 4     | 18 (226)
            LD      (HL), A             ; write to PSG          ' 7     |

psg_tone_write0
            LD      A, (DE)             ; A = PSG data          ' 7     |
            INC     E                   ; next data             ' 4     | 18 (244)
            LD      (HL), A             ; write to PSG          ' 7     |

            JP      execute_xgm         ;                       ' 10    | (254)


com_psg_env_w0                          ; 18                    ' 80
            wait72                      ; sync                  ' 72    |
            LD      HL, PSGPORT         ; HL point on PSG port  ' 10    | 102 (182)
            LD      BC, PSG_ENV_SAV     ; BC point on PSG save  ' 10    |
            JP      psg_env_write0      ;                       ' 10    |

com_psg_env_w1                          ; 18                    ' 80
            wait10                      ; sync                  ' 10    |
            LD      HL, PSGPORT         ; HL point on PSG port  ' 10    | 40 (120)
            LD      BC, PSG_ENV_SAV     ; BC point on PSG save  ' 10    |
            JP      psg_env_write1      ;                       ' 10    |

com_psg_env_w2                          ; 18                    ' 80
            wait154                     ; sync                  ' 154   |
            LD      HL, PSGPORT         ; HL point on PSG port  ' 10    | 174 (254)
            LD      BC, PSG_ENV_SAV     ; BC point on PSG save  ' 10    |

            sampleOutput                ;                       ' 36    | (36)

            wait12                      ; sync                  ' 12    |
            JP      psg_env_write2      ;                       ' 10    | 22 (58)

com_psg_env_w3                          ; 18                    ' 80
            wait110                     ; sync                  ' 110   |
            LD      HL, PSGPORT         ; HL point on PSG port  ' 10    | 130 (210)
            LD      BC, PSG_ENV_SAV     ; BC point on PSG save  ' 10    |

psg_env_write3
            LD      A, (DE)             ; A = PSG data          ' 7     |
            RLCA                        ;                       ' 4     |
            RLCA                        ;                       ' 4     |
            RLCA                        ;                       ' 4     |
            AND     $3                  ; A = channel number    ' 7     | 41 (254-3)
            ADD    (PSG_ENV_SAV & $FF)  ; add offset            ' 7     |
            LD      C, A                ; BC point on save      ' 4     |
            wait4                       ; sync                  ' 4     |

            sampleOutput                ;                       ' 36    | (36-3)

            LD      A, (DE)             ; A = PSG data          ' 7     |
            INC     E                   ; next data             ' 4     | 25 (58)
            LD      (HL), A             ; write to PSG          ' 7     |
            LD      (BC), A             ; write to save         ' 7     |

psg_env_write2                          ;                       ' 58
            LD      A, (DE)             ; A = PSG data          ' 7     |
            RLCA                        ;                       ' 4     |
            RLCA                        ;                       ' 4     |
            RLCA                        ;                       ' 4     |
            AND     $3                  ; A = channel number    ' 7     |
            ADD    (PSG_ENV_SAV & $FF)  ; add offset            ' 7     | 62 (120)
            LD      C, A                ; BC point on save      ' 4     |
            LD      A, (DE)             ; A = PSG data          ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      (HL), A             ; write to PSG          ' 7     |
            LD      (BC), A             ; write to save         ' 7     |

psg_env_write1
            LD      A, (DE)             ; A = PSG data          ' 7     |
            RLCA                        ;                       ' 4     |
            RLCA                        ;                       ' 4     |
            RLCA                        ;                       ' 4     |
            AND     $3                  ; A = channel number    ' 7     |
            ADD    (PSG_ENV_SAV & $FF)  ; add offset            ' 7     | 62 (182)
            LD      C, A                ; BC point on save      ' 4     |
            LD      A, (DE)             ; A = PSG data          ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      (HL), A             ; write to PSG          ' 7     |
            LD      (BC), A             ; write to save         ' 7     |

psg_env_write0
            LD      A, (DE)             ; A = PSG data          ' 7     |
            RLCA                        ;                       ' 4     |
            RLCA                        ;                       ' 4     |
            RLCA                        ;                       ' 4     |
            AND     $3                  ; A = channel number    ' 7     |
            ADD    (PSG_ENV_SAV & $FF)  ; add offset            ' 7     | 62 (244)
            LD      C, A                ; BC point on save      ' 4     |
            LD      A, (DE)             ; A = PSG data          ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      (HL), A             ; write to PSG          ' 7     |
            LD      (BC), A             ; write to save         ' 7     |

            JP      execute_xgm         ;                       ' 10    | (254)


; YM port0 command
; ----------------

com_ym_port0_w0                         ; 20                    ' 80
            wait36                      ; sync                  ' 36    |
            LD      HL, YMPORT0         ; HL point on YM port0  ' 10    | 66 (146)
            LD      BC, YMPORT1         ; BC point on YM port1  ' 10    |
            JP      ym_port_write0      ;                       ' 10    |

com_ym_port0_w1                         ; 21                    ' 80
            LD      HL, YMPORT0         ; HL point on YM port0  ' 10    |
            LD      BC, YMPORT1         ; BC point on YM port1  ' 10    | 30 (110)
            JP      ym_port_write1      ;                       ' 10    |

com_ym_port0_w2                         ; 22                    ' 80
            wait52                      ; sync                  ' 52    |
            LD      HL, YMPORT0         ; HL point on YM port0  ' 10    | 82 (162)
            LD      BC, YMPORT1         ; BC point on YM port1  ' 10    |
            JP      ym_port_write2      ;                       ' 10    |

com_ym_port0_w3                         ; 23                    ' 80
            LD      HL, YMPORT0         ; HL point on YM port0  ' 10    |
            LD      BC, HL              ; BC point on YM port0  ' 10    |
            INC     BC                  ; BC point on YM port1  ' 6     | 36 (116)
            JP      com_ym_port_w3      ; execute               ' 10    |

com_ym_port0_w4                         ; 24                    ' 80
            wait144                     ; sync                  ' 144   |
            LD      HL, YMPORT0         ; HL point on YM port0  ' 10    | 178 (254+4)
            LD      BC, YMPORT1         ; BC point on YM port1  ' 10    |
            EXX                         ;                       ' 4     |
            JP      ym_port_write4      ;                       ' 10    |

com_ym_port0_w5                         ; 25                    ' 80
            wait52                      ; sync                  ' 52    |
            LD      HL, YMPORT0         ; HL point on YM port0  ' 10    | 82 (162)
            LD      BC, YMPORT1         ; BC point on YM port1  ' 10    |
            JP      ym_port_write5      ;                       ' 10    |

com_ym_port0_w6                         ; 26                    ' 80
            LD      HL, YMPORT0         ; HL point on YM port0  ' 10    |
            LD      BC, HL              ; BC point on YM port0  ' 10    |
            INC     BC                  ; BC point on YM port1  ' 6     | 36 (116)
            JP      com_ym_port_w6      ; execute               ' 10    |

com_ym_port0_w7                         ; 27                    ' 80
            wait144                     ; sync                  ' 144   |
            LD      HL, YMPORT0         ; HL point on YM port0  ' 10    | 178 (254+4)
            LD      BC, YMPORT1         ; BC point on YM port1  ' 10    |
            EXX                         ;                       ' 4     |
            JP      ym_port_write7      ;                       ' 10    |

com_ym_port0_w8                         ; 28                    ' 80
            wait52                      ; sync                  ' 52    |
            LD      HL, YMPORT0         ; HL point on YM port0  ' 10    | 82 (162)
            LD      BC, YMPORT1         ; BC point on YM port1  ' 10    |
            JP      ym_port_write8      ;                       ' 10    |

com_ym_port0_w9                         ; 29                    ' 80
            LD      HL, YMPORT0         ; HL point on YM port0  ' 10    |
            LD      BC, HL              ; BC point on YM port0  ' 10    |
            INC     BC                  ; BC point on YM port1  ' 6     | 36 (116)
            JP      com_ym_port_w9      ; execute               ' 10    |

com_ym_port0_wA                         ; 2A                    ' 80
            wait144                     ; sync                  ' 144   |
            LD      HL, YMPORT0         ; HL point on YM port0  ' 10    | 178 (254+4)
            LD      BC, YMPORT1         ; BC point on YM port1  ' 10    |
            EXX                         ;                       ' 4     |
            JP      ym_port_writeA      ;                       ' 10    |

com_ym_port0_wB                         ; 2B                    ' 80
            wait52                      ; sync                  ' 52    |
            LD      HL, YMPORT0         ; HL point on YM port0  ' 10    | 82 (162)
            LD      BC, YMPORT1         ; BC point on YM port1  ' 10    |
            JP      ym_port_writeB      ;                       ' 10    |

com_ym_port0_wC                         ; 2C                    ' 80
            LD      HL, YMPORT0         ; HL point on YM port0  ' 10    |
            LD      BC, HL              ; BC point on YM port0  ' 10    |
            INC     BC                  ; BC point on YM port1  ' 6     | 36 (116)
            JP      com_ym_port_wC      ; execute               ' 10    |

com_ym_port0_wD                         ; 2D                    ' 80
            wait144                     ; sync                  ' 144   |
            LD      HL, YMPORT0         ; HL point on YM port0  ' 10    | 174 (254)
            LD      BC, YMPORT1         ; BC point on YM port1  ' 10    |
            JP      ym_port_writeD      ;                       ' 10    |

com_ym_port0_wE                         ; 2E                    ' 80
            wait36                      ; sync                  ' 36    |
            LD      HL, YMPORT0         ; HL point on YM port0  ' 10    | 66 (146)
            LD      BC, YMPORT1         ; BC point on YM port1  ' 10    |
            JP      ym_port_writeE      ;                       ' 10    |

com_ym_port0_wF                         ; 2F                    ' 80
            LD      HL, YMPORT0         ; HL point on YM port0  ' 10    |
            LD      BC, YMPORT1         ; BC point on YM port1  ' 10    | 30 (110)
            JP      ym_port_writeF      ;                       ' 10    |


; YM port2 command
; ----------------

com_ym_port2_w0                         ; 30                    ' 80
            wait36                      ; sync                  ' 36    |
            LD      HL, YMPORT2         ; HL point on YM port2  ' 10    | 66 (146)
            LD      BC, YMPORT3         ; BC point on YM port3  ' 10    |
            JP      ym_port_write0      ;                       ' 10    |

com_ym_port2_w1                         ; 31                    ' 80
            LD      HL, YMPORT2         ; HL point on YM port2  ' 10    |
            LD      BC, YMPORT3         ; BC point on YM port3  ' 10    | 30 (110)
            JP      ym_port_write1      ;                       ' 10    |

com_ym_port2_w2                         ; 32                    ' 80
            wait52                      ; sync                  ' 52    |
            LD      HL, YMPORT2         ; HL point on YM port2  ' 10    | 82 (162)
            LD      BC, YMPORT3         ; BC point on YM port3  ' 10    |
            JP      ym_port_write2      ;                       ' 10    |

com_ym_port2_w3                         ; 33                    ' 80
            LD      HL, YMPORT2         ; HL point on YM port2  ' 10    |
            LD      BC, HL              ; BC point on YM port2  ' 10    |
            INC     BC                  ; BC point on YM port3  ' 6     | 36 (116)
            JP      com_ym_port_w3      ; execute               ' 10    |

com_ym_port2_w4                         ; 34                    ' 80
            wait144                     ; sync                  ' 144   |
            LD      HL, YMPORT2         ; HL point on YM port0  ' 10    | 178 (254+4)
            LD      BC, YMPORT3         ; BC point on YM port3  ' 10    |
            EXX                         ;                       ' 4     |
            JP      ym_port_write4      ;                       ' 10    |

com_ym_port2_w5                         ; 35                    ' 80
            wait52                      ; sync                  ' 52    |
            LD      HL, YMPORT2         ; HL point on YM port2  ' 10    | 82 (162)
            LD      BC, YMPORT3         ; BC point on YM port3  ' 10    |
            JP      ym_port_write5      ;                       ' 10    |

com_ym_port2_w6                         ; 36                    ' 80
            LD      HL, YMPORT2         ; HL point on YM port2  ' 10    |
            LD      BC, HL              ; BC point on YM port2  ' 10    |
            INC     BC                  ; BC point on YM port3  ' 6     | 36 (116)
            JP      com_ym_port_w6      ; execute               ' 10    |

com_ym_port2_w7                         ; 37                    ' 80
            wait144                     ; sync                  ' 144   |
            LD      HL, YMPORT2         ; HL point on YM port0  ' 10    | 178 (254+4)
            LD      BC, YMPORT3         ; BC point on YM port3  ' 10    |
            EXX                         ;                       ' 4     |
            JP      ym_port_write7      ;                       ' 10    |

com_ym_port2_w8                         ; 38                    ' 80
            wait52                      ; sync                  ' 52    |
            LD      HL, YMPORT2         ; HL point on YM port2  ' 10    | 82 (162)
            LD      BC, YMPORT3         ; BC point on YM port3  ' 10    |
            JP      ym_port_write8      ;                       ' 10    |

com_ym_port2_w9                         ; 39                    ' 80
            LD      HL, YMPORT2         ; HL point on YM port2  ' 10    |
            LD      BC, HL              ; BC point on YM port2  ' 10    |
            INC     BC                  ; BC point on YM port3  ' 6     | 36 (116)
            JP      com_ym_port_w9      ; execute               ' 10    |

com_ym_port2_wA                         ; 3A                    ' 80
            wait144                     ; sync                  ' 144   |
            LD      HL, YMPORT2         ; HL point on YM port0  ' 10    | 178 (254+4)
            LD      BC, YMPORT3         ; BC point on YM port3  ' 10    |
            EXX                         ;                       ' 4     |
            JP      ym_port_writeA      ;                       ' 10    |

com_ym_port2_wB                         ; 3B                    ' 80
            wait52                      ; sync                  ' 52    |
            LD      HL, YMPORT2         ; HL point on YM port2  ' 10    | 82 (162)
            LD      BC, YMPORT3         ; BC point on YM port3  ' 10    |
            JP      ym_port_writeB      ;                       ' 10    |

com_ym_port2_wC                         ; 3C                    ' 80
            LD      HL, YMPORT2         ; HL point on YM port2  ' 10    |
            LD      BC, HL              ; BC point on YM port2  ' 10    |
            INC     BC                  ; BC point on YM port3  ' 6     | 36 (116)
            JP      com_ym_port_wC      ; execute               ' 10    |

com_ym_port2_wD                         ; 3D                    ' 80
            wait144                     ; sync                  ' 144   |
            LD      HL, YMPORT2         ; HL point on YM port2  ' 10    | 174 (254)
            LD      BC, YMPORT3         ; BC point on YM port3  ' 10    |
            JP      ym_port_writeD      ;                       ' 10    |

com_ym_port2_wE                         ; 3E                    ' 80
            wait36                      ; sync                  ' 36    |
            LD      HL, YMPORT2         ; HL point on YM port2  ' 10    | 66 (146)
            LD      BC, YMPORT3         ; BC point on YM port3  ' 10    |
            JP      ym_port_writeE      ;                       ' 10    |

com_ym_port2_wF                         ; 3F                    ' 80
            LD      HL, YMPORT2         ; HL point on YM port2  ' 10    |
            LD      BC, YMPORT3         ; BC point on YM port3  ' 10    | 30 (110)
            JP      ym_port_writeF      ;                       ' 10    |


com_ym_port_w3                          ;                       ' 116
            LD      A, (DE)             ; A = YM reg num        ' 7     |
            LD      (HL), A             ; write reg num to YM   ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      A, (DE)             ; A = YM reg data       ' 7     | 36 (152)
            INC     E                   ; next data             ' 4     |
            LD      (BC), A             ; write data to YM      ' 7     |
            JP      ym_port_write2      ;                       ' 10    | (162)

com_ym_port_w6                          ;                       ' 116
            LD      A, (DE)             ; A = YM reg num        ' 7     |
            LD      (HL), A             ; write reg num to YM   ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      A, (DE)             ; A = YM reg data       ' 7     | 36 (152)
            INC     E                   ; next data             ' 4     |
            LD      (BC), A             ; write data to YM      ' 7     |
            JP      ym_port_write5      ;                       ' 10    | (162)

com_ym_port_w9                          ;                       ' 116
            LD      A, (DE)             ; A = YM reg num        ' 7     |
            LD      (HL), A             ; write reg num to YM   ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      A, (DE)             ; A = YM reg data       ' 7     | 36 (152)
            INC     E                   ; next data             ' 4     |
            LD      (BC), A             ; write data to YM      ' 7     |
            JP      ym_port_write8      ;                       ' 10    | (162)

com_ym_port_wC                          ;                       ' 116
            LD      A, (DE)             ; A = YM reg num        ' 7     |
            LD      (HL), A             ; write reg num to YM   ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      A, (DE)             ; A = YM reg data       ' 7     | 36 (152)
            INC     E                   ; next data             ' 4     |
            LD      (BC), A             ; write data to YM      ' 7     |
            JP      ym_port_writeB      ;                       ' 10    | (162)


ym_port_write1                          ;                       ' 110
            LD      A, (DE)             ; A = YM reg num        ' 7     |
            LD      (HL), A             ; write reg num to YM   ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      A, (DE)             ; A = YM reg data       ' 7     | 36 (146)
            INC     E                   ; next data             ' 4     |
            LD      (BC), A             ; write data to YM      ' 7     |

ym_port_write0
            LD      A, (DE)             ; A = YM reg num        ' 7     |
            waitYMReady                 ; wait YM to be ready   ' 30    |
            LD      (HL), A             ; write reg num to YM   ' 7     | 66 (212)
            INC     E                   ; next data             ' 4     |
            LD      A, (DE)             ; A = YM reg data       ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      (BC), A             ; write to YM           ' 7     |

            EXX                         ; switch to HL' (port0) ' 4     |
.wait                                   ;                       '       |
            BIT     7, (HL)             ; test YM ready bit     ' 12    |
            JP      NZ, .wait           ; wait while busy       ' 10    | 40 (252)
                                        ;                       '       |
            LD      (HL), $2A           ; restore DAC write     ' 10    |
            EXX                         ; switch back           ' 4     |

            JP      execute_xgm         ; +8 cycles here        ' 10    | (254+8)

ym_port_writeF                          ;                       ' 110
            LD      A, (DE)             ; A = YM reg num        ' 7     |
            LD      (HL), A             ; write reg num to YM   ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      A, (DE)             ; A = YM reg data       ' 7     | 36 (146)
            INC     E                   ; next data             ' 4     |
            LD      (BC), A             ; write data to YM      ' 7     |

ym_port_writeE
            LD      A, (DE)             ; A = YM reg num        ' 7     |
            waitYMReady                 ; wait YM to be ready   ' 30    |
            LD      (HL), A             ; write reg num to YM   ' 7     | 66 (212)
            INC     E                   ; next data             ' 4     |
            LD      A, (DE)             ; A = YM reg data       ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      (BC), A             ; write to YM           ' 7     |

            wait12                      ; sync                  ' 12    |
            waitYMReady                 ; wait YM to be ready   ' 30    | 42 (254)

ym_port_writeD
            sampleOutputSafe            ;                       ' 46    | (46)

            LD      A, (DE)             ; A = YM reg num        ' 7     |
            waitYMReady                 ; wait YM to be ready   ' 30    |
            LD      (HL), A             ; write reg num to YM   ' 7     | 66 (112)
            INC     E                   ; next data             ' 4     |
            LD      A, (DE)             ; A = YM reg data       ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      (BC), A             ; write to YM           ' 7     |

;ym_port_writeC
            LD      A, (DE)             ; A = YM reg num        ' 7     |
            waitYMReady                 ; wait YM to be ready   ' 30    |
            LD      (HL), A             ; write reg num to YM   ' 7     | 66 (178)
            INC     E                   ; next data             ' 4     |
            LD      A, (DE)             ; A = YM reg data       ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      (BC), A             ; write to YM           ' 7     |

ym_port_writeB
            LD      A, (DE)             ; A = YM reg num        ' 7     |
            waitYMReady                 ; wait YM to be ready   ' 30    |
            LD      (HL), A             ; write reg num to YM   ' 7     | 66 (244)
            INC     E                   ; next data             ' 4     |
            LD      A, (DE)             ; A = YM reg data       ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      (BC), A             ; write to YM           ' 7     |

            EXX                         ; switch to HL' (port0) ' 4     | (248)
.wait                                   ;                       '       |
            BIT     7, (HL)             ; test YM ready bit     ' 12    |
            JP      NZ, .wait           ; wait while busy       ' 10    | 22 (258+14)

ym_port_writeA                          ;                       ' 4
            LD      (HL), $2A           ; restore DAC write     ' 10    |
            LD      A, (BC)             ;                       ' 7     |
            INC     BC                  ; play sample           ' 6     | 42 (46)
            RES     2, B                ;                       ' 8     |
            LD      (DE), A             ;                       ' 7     |
            EXX                         ;                       ' 4     |

            LD      A, (DE)             ; A = YM reg num        ' 7     |
            waitYMReady                 ; wait YM to be ready   ' 30    |
            LD      (HL), A             ; write reg num to YM   ' 7     | 66 (112)
            INC     E                   ; next data             ' 4     |
            LD      A, (DE)             ; A = YM reg data       ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      (BC), A             ; write to YM           ' 7     |

;ym_port_write9
            LD      A, (DE)             ; A = YM reg num        ' 7     |
            waitYMReady                 ; wait YM to be ready   ' 30    |
            LD      (HL), A             ; write reg num to YM   ' 7     | 66 (178)
            INC     E                   ; next data             ' 4     |
            LD      A, (DE)             ; A = YM reg data       ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      (BC), A             ; write to YM           ' 7     |

ym_port_write8
            LD      A, (DE)             ; A = YM reg num        ' 7     |
            waitYMReady                 ; wait YM to be ready   ' 30    |
            LD      (HL), A             ; write reg num to YM   ' 7     | 66 (244)
            INC     E                   ; next data             ' 4     |
            LD      A, (DE)             ; A = YM reg data       ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      (BC), A             ; write to YM           ' 7     |

            EXX                         ; switch to HL' (port0) ' 4     | (248)
.wait                                   ;                       '       |
            BIT     7, (HL)             ; test YM ready bit     ' 12    |
            JP      NZ, .wait           ; wait while busy       ' 10    | 22 (258+14)

ym_port_write7                          ;                       ' 4
            LD      (HL), $2A           ; restore DAC write     ' 10    |
            LD      A, (BC)             ;                       ' 7     |
            INC     BC                  ; play sample           ' 6     | 42 (46)
            RES     2, B                ;                       ' 8     |
            LD      (DE), A             ;                       ' 7     |
            EXX                         ;                       ' 4     |

            LD      A, (DE)             ; A = YM reg num        ' 7     |
            waitYMReady                 ; wait YM to be ready   ' 30    |
            LD      (HL), A             ; write reg num to YM   ' 7     | 66 (112)
            INC     E                   ; next data             ' 4     |
            LD      A, (DE)             ; A = YM reg data       ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      (BC), A             ; write to YM           ' 7     |

;ym_port_write6
            LD      A, (DE)             ; A = YM reg num        ' 7     |
            waitYMReady                 ; wait YM to be ready   ' 30    |
            LD      (HL), A             ; write reg num to YM   ' 7     | 66 (178)
            INC     E                   ; next data             ' 4     |
            LD      A, (DE)             ; A = YM reg data       ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      (BC), A             ; write to YM           ' 7     |

ym_port_write5
            LD      A, (DE)             ; A = YM reg num        ' 7     |
            waitYMReady                 ; wait YM to be ready   ' 30    |
            LD      (HL), A             ; write reg num to YM   ' 7     | 66 (244)
            INC     E                   ; next data             ' 4     |
            LD      A, (DE)             ; A = YM reg data       ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      (BC), A             ; write to YM           ' 7     |

            EXX                         ; switch to HL' (port0) ' 4     | (248)
.wait                                   ;                       '       |
            BIT     7, (HL)             ; test YM ready bit     ' 12    |
            JP      NZ, .wait           ; wait while busy       ' 10    | 22 (258+14)

ym_port_write4                          ;                       ' 4
            LD      (HL), $2A           ; restore DAC write     ' 10    |
            LD      A, (BC)             ;                       ' 7     |
            INC     BC                  ; play sample           ' 6     | 42 (46)
            RES     2, B                ;                       ' 8     |
            LD      (DE), A             ;                       ' 7     |
            EXX                         ;                       ' 4     |

            LD      A, (DE)             ; A = YM reg num        ' 7     |
            waitYMReady                 ; wait YM to be ready   ' 30    |
            LD      (HL), A             ; write reg num to YM   ' 7     | 66 (112)
            INC     E                   ; next data             ' 4     |
            LD      A, (DE)             ; A = YM reg data       ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      (BC), A             ; write to YM           ' 7     |

;ym_port_write3
            LD      A, (DE)             ; A = YM reg num        ' 7     |
            waitYMReady                 ; wait YM to be ready   ' 30    |
            LD      (HL), A             ; write reg num to YM   ' 7     | 66 (178)
            INC     E                   ; next data             ' 4     |
            LD      A, (DE)             ; A = YM reg data       ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      (BC), A             ; write to YM           ' 7     |

ym_port_write2
            LD      A, (DE)             ; A = YM reg num        ' 7     |
            waitYMReady                 ; wait YM to be ready   ' 30    |
            LD      (HL), A             ; write reg num to YM   ' 7     | 66 (244)
            INC     E                   ; next data             ' 4     |
            LD      A, (DE)             ; A = YM reg data       ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      (BC), A             ; write to YM           ' 7     |

            EXX                         ; switch to HL' (port0) ' 4     | (248)
.wait                                   ;                       '       |
            BIT     7, (HL)             ; test YM ready bit     ' 12    |
            JP      NZ, .wait           ; wait while busy       ' 10    | 22 (258+14)

            LD      (HL), $2A           ; restore DAC write     ' 10    |
            LD      A, (BC)             ;                       ' 7     |
            INC     BC                  ; play sample           ' 6     | 42 (46)
            RES     2, B                ;                       ' 8     |
            LD      (DE), A             ;                       ' 7     |
            EXX                         ;                       ' 4     |

            wait24                      ; sync                  ' 24    | 54 (100)
            waitYMReady                 ; wait YM to be ready   ' 30    |

            JP      ym_port_write1      ; execute next          ' 10    | (110)


; YM KEY command
; --------------

com_ym_key_w0                           ; 40                    ' 80
            wait44                      ; sync                  ' 44    |
            LD      HL, YMPORT0         ; HL point on YM port0  ' 10    |
            LD      BC, YMPORT1         ; BC point on YM port1  ' 10    | 84 (164)
            LD      (HL), $28           ; set reg num to YM     ' 10    |
            JP      ym_key_write0       ;                       ' 10    |

com_ym_key_w1                           ; 41                    ' 80
            wait4                       ; sync                  ' 4     |
            LD      HL, YMPORT0         ; HL point on YM port0  ' 10    |
            LD      BC, YMPORT1         ; BC point on YM port1  ' 10    | 44 (124)
            LD      (HL), $28           ; set reg num to YM     ' 10    |
            JP      ym_key_write1       ;                       ' 10    |

com_ym_key_w2                           ; 43                    ' 80
            wait134                     ; sync                  ' 134   |
            LD      HL, YMPORT0         ; HL point on YM port0  ' 10    |
            LD      BC, YMPORT1         ; BC point on YM port1  ' 10    |
            LD      (HL), $28           ; set reg num to YM     ' 10    | 174 (254)
            JP      ym_key_write2       ;                       ' 10    |

com_ym_key_w3                           ; 44                    ' 80
            wait64                      ; sync                  ' 64    |
            LD      HL, YMPORT0         ; HL point on YM port0  ' 10    |
            LD      BC, YMPORT1         ; BC point on YM port1  ' 10    |
            LD      (HL), $28           ; set reg num to YM     ' 10    | 104 (184)
            JP      ym_key_write3       ;                       ' 10    |

com_ym_key_w4                           ; 45                    ' 80
            wait24                      ; sync                  ' 24    |
            LD      HL, YMPORT0         ; HL point on YM port0  ' 10    |
            LD      BC, YMPORT1         ; BC point on YM port1  ' 10    |
            LD      (HL), $28           ; set reg num to YM     ' 10    | 64 (144)
            JP      ym_key_write4       ;                       ' 10    |

com_ym_key_w5                           ; 46                    ' 80
            wait154                     ; sync                  ' 174   |
            LD      HL, YMPORT0         ; HL point on YM port0  ' 10    | 174 (254)
            LD      BC, YMPORT1         ; BC point on YM port1  ' 10    |

            sampleOutputSafe            ;                       ' 46    | (46)

            wait16                      ; sync                  ' 16    |
            waitYMReadyFast             ; wait YM to be ready   ' 22    |
            LD      (HL), $28           ; set reg num to YM     ' 10    | 58 (104)
            JP      ym_key_write5       ;                       ' 10    |


ym_key_write1                           ;                       ' 124
            LD      A, (DE)             ; A = YM key data       ' 7     |
            INC     E                   ; next data             ' 4     |
            waitYMReadyFast             ; wait YM to be ready   ' 22    | 40 (164)
            LD      (BC), A             ; write to YM           ' 7     |

ym_key_write0                           ;                       ' 164
            LD      A, (DE)             ; A = YM key data       ' 7     |
            INC     E                   ; next data             ' 4     |
            waitYMReadyFast             ; wait YM to be ready   ' 22    | 40 (204)
            LD      (BC), A             ; write to YM           ' 7     |

            wait8                       ; sync                  ' 8     |
            waitYMReadyFast             ; wait YM to be ready   ' 22    | 40 (244)
            LD      (HL), $2A           ; restore DAC write     ' 10    |

            JP      execute_xgm         ;                       ' 10    | (254)

ym_key_write5                           ;                       ' 104
            LD      A, (DE)             ; A = YM key data       ' 7     |
            INC     E                   ; next data             ' 4     |
            waitYMReadyFast             ; wait YM to be ready   ' 22    | 40 (144)
            LD      (BC), A             ; write to YM           ' 7     |

ym_key_write4                           ;                       ' 144
            LD      A, (DE)             ; A = YM key data       ' 7     |
            INC     E                   ; next data             ' 4     |
            waitYMReadyFast             ; wait YM to be ready   ' 22    | 40 (184)
            LD      (BC), A             ; write to YM           ' 7     |

ym_key_write3                           ;                       ' 184
            LD      A, (DE)             ; A = YM key data       ' 7     |
            INC     E                   ; next data             ' 4     |
            waitYMReadyFast             ; wait YM to be ready   ' 22    | 40 (224)
            LD      (BC), A             ; write to YM           ' 7     |

            wait8                       ; sync                  ' 8     |
            waitYMReadyFast             ; wait YM to be ready   ' 22    | 30 (254)

ym_key_write2
            sampleOutputSafe            ;                       ' 46    | (46)

            wait8                       ; sync                  ' 8     |
            waitYMReadyFast             ; wait YM to be ready   ' 22    | 40 (86)
            LD      (HL), $28           ; restore write to key  ' 10    |

            LD      A, (DE)             ; A = YM key data       ' 7     |
            INC     DE                  ; next data             ' 6     |
            waitYMReadyFast             ; wait YM to be ready   ' 22    | 40 (126)
            LD      (BC), A             ; write to YM           ' 7     |

.write1
            LD      A, (DE)             ; A = YM key data       ' 7     |
            INC     E                   ; next data             ' 4     |
            waitYMReadyFast             ; wait YM to be ready   ' 22    | 40 (166)
            LD      (BC), A             ; write to YM           ' 7     |

.write0
            LD      A, (DE)             ; A = YM key data       ' 7     |
            INC     E                   ; next data             ' 4     |
            waitYMReadyFast             ; wait YM to be ready   ' 22    | 40 (206)
            LD      (BC), A             ; write to YM           ' 7     |

            wait7                       ; sync                  ' 7     |
            waitYMReadyFast             ; wait YM to be ready   ' 22    | 39 (245)
            LD      (HL), $2A           ; restore DAC write     ' 10    |

            JP      execute_xgm         ;                       ' 10    | (254+1)


; PCM command
; -----------

com_pcm_p0_ch0                          ; 50                    ' 80
            LD      C, 0                ; C = prio              ' 7     |
            JP      com_pcm_ch0         ; execute PCM com       ' 10    | 17 (97)

com_pcm_p1_ch0                          ; 54                    ' 80
            LD      C, 1                ; C = prio              ' 7     |
            JP      com_pcm_ch0         ; execute PCM com       ' 10    | 17 (97)

com_pcm_p2_ch0                          ; 58                    ' 80
            LD      C, 2                ; C = prio              ' 7     |
            JP      com_pcm_ch0         ; execute PCM com       ' 10    | 17 (97)

com_pcm_p3_ch0                          ; 5C                    ' 80
            LD      C, 3                ; C = prio              ' 7     |
            JP      com_pcm_ch0         ; execute PCM com       ' 10    | 17 (97)

com_pcm_p0_ch1                          ; 51                    ' 80
            LD      C, 0                ; C = prio              ' 7     |
            JP      com_pcm_ch1         ; execute PCM com       ' 10    | 17 (97)

com_pcm_p1_ch1                          ; 55                    ' 80
            LD      C, 1                ; C = prio              ' 7     |
            JP      com_pcm_ch0         ; execute PCM com       ' 10    | 17 (97)

com_pcm_p2_ch1                          ; 59                    ' 80
            LD      C, 2                ; C = prio              ' 7     |
            JP      com_pcm_ch1         ; execute PCM com       ' 10    | (119)

com_pcm_p3_ch1                          ; 5D                    ' 80
            LD      C, 3                ; C = prio              ' 7     |
            JP      com_pcm_ch1         ; execute PCM com       ' 10    | (119)

com_pcm_p0_ch2                          ; 52                    ' 80
            LD      C, 0                ; C = prio              ' 7     |
            JP      com_pcm_ch2         ; execute PCM com       ' 10    | (119)

com_pcm_p1_ch2                          ; 56                    ' 80
            LD      C, 1                ; C = prio              ' 7     |
            JP      com_pcm_ch2         ; execute PCM com       ' 10    | (119)

com_pcm_p2_ch2                          ; 5A                    ' 80
            LD      C, 2                ; C = prio              ' 7     |
            JP      com_pcm_ch2         ; execute PCM com       ' 10    | (119)

com_pcm_p3_ch2                          ; 5E                    ' 80
            LD      C, 3                ; C = prio              ' 7     |
            JP      com_pcm_ch2         ; execute PCM com       ' 10    | (119)

com_pcm_p0_ch3                          ; 53                    ' 80
            LD      C, 0                ; C = prio              ' 7     |
            JP      com_pcm_ch3         ; execute PCM com       ' 10    | (119)

com_pcm_p1_ch3                          ; 57                    ' 80
            LD      C, 1                ; C = prio              ' 7     |
            JP      com_pcm_ch3         ; execute PCM com       ' 10    | (119)

com_pcm_p2_ch3                          ; 5B                    ' 80
            LD      C, 2                ; C = prio              ' 7     |
            JP      com_pcm_ch3         ; execute PCM com       ' 10    | (119)

com_pcm_p3_ch3                          ; 5F                    ' 80
            LD      C, 3                ; C = prio              ' 7     |
            JP      com_pcm_ch3         ; execute PCM com       ' 10    | (119)


com_pcm_ch0                             ;                       ' 97
            handlePCMCommandXGM 0       ; handle command        ' 142   |
            wait4                       ; sync                  ' 4     | 156 (254-1)
            JP      execute_xgm         ;                       ' 10    |

com_pcm_ch1                             ;                       ' 97
            handlePCMCommandXGM 1       ; handle command        ' 142   |
            wait4                       ; sync                  ' 4     | 156 (254-1)
            JP      execute_xgm         ;                       ' 10    |

com_pcm_ch2                             ;                       ' 97
            handlePCMCommandXGM 2       ; handle command        ' 142   |
            wait4                       ; sync                  ' 4     | 156 (254-1)
            JP      execute_xgm         ;                       ' 10    |

com_pcm_ch3                             ;                       ' 97
            handlePCMCommandXGM 3       ; handle command        ' 142   |
            wait4                       ; sync                  ' 4     | 156 (254-1)
            JP      execute_xgm         ;                       ' 10    |



; STATE command
; -------------

com_state_w0                            ; 60                    ' 80
            wait114                     ; sync                  ' 114   |
            LD      H, (YM_RR_SAV >> 8) ; H point on YM save H  ' 7     | 131 (211)
            JP      state_w0            ; execute               ' 10    |

com_state_w1                            ; 61                    ' 80
            wait81                      ; sync                  ' 81    |
            LD      H, (YM_RR_SAV >> 8) ; H point on YM save H  ' 7     | 98 (178)
            JP      state_w1            ; execute               ' 10    |

com_state_w2                            ; 62                    ' 80
            wait48                      ; sync                  ' 48    |
            LD      H, (YM_RR_SAV >> 8) ; H point on YM save H  ' 7     | 65 (145)
            JP      state_w2            ; execute               ' 10    |

com_state_w3                            ; 63                    ' 80
            wait15                      ; sync                  ' 15    |
            LD      H, (YM_RR_SAV >> 8) ; H point on YM save H  ' 7     | 32 (112)
            JP      state_w3            ; execute               ' 10    |

com_state_w4                            ; 64                    ' 80
            wait174                     ; sync                  ' 174   | (254)
            sampleOutput                ; sample output         ' 36    | (36)

            wait26                      ; sync                  ' 26    |
            LD      H, (YM_RR_SAV >> 8) ; H point on YM save H  ' 7     | 43 (79)
            JP      state_w4            ; execute               ' 10    |

com_state_w5                            ; 65                    ' 80
            wait157                     ; sync                  ' 157   |
            LD      H, (YM_RR_SAV >> 8) ; H point on YM save H  ' 7     | 174 (254)
            JP      state_w5            ; execute               ' 10    |

com_state_w6                            ; 66                    ' 80
            wait124                     ; sync                  ' 124   |
            LD      H, (YM_RR_SAV >> 8) ; H point on YM save H  ' 7     | 141 (221)
            JP      state_w6            ; execute               ' 10    |

com_state_w7                            ; 67                    ' 80
            wait91                      ; sync                  ' 91    |
            LD      H, (YM_RR_SAV >> 8) ; H point on YM save H  ' 7     | 108 (188)
            JP      state_w7            ; execute               ' 10    |

com_state_w8                            ; 68                    ' 80
            wait58                      ; sync                  ' 58    |
            LD      H, (YM_RR_SAV >> 8) ; H point on YM save H  ' 7     | 75 (155)
            JP      state_w8            ; execute               ' 10    |

com_state_w9                            ; 69                    ' 80
            wait25                      ; sync                  ' 25    |
            LD      H, (YM_RR_SAV >> 8) ; H point on YM save H  ' 7     | 42 (122)
            JP      state_w9            ; execute               ' 10    |

com_state_wA                            ; 6A                    ' 80
            wait174                     ; sync                  ' 174   | (254)
            sampleOutput                ; sample output         ' 36    | (36)

            wait36                      ; sync                  ' 36    |
            LD      H, (YM_RR_SAV >> 8) ; H point on YM save H  ' 7     | 53 (89)
            JP      state_wA            ; execute               ' 10    |

com_state_wB                            ; 6B                    ' 80
            wait157                     ; sync                  ' 157   |
            LD      H, (YM_RR_SAV >> 8) ; H point on YM save H  ' 7     | 174 (254)
            JP      state_wB            ; execute               ' 10    |

com_state_wC                            ; 6C                    ' 80
            wait124                     ; sync                  ' 124   |
            LD      H, (YM_RR_SAV >> 8) ; H point on YM save H  ' 7     | 141 (221)
            JP      state_wC            ; execute               ' 10    |

com_state_wD                            ; 6D                    ' 80
            wait91                      ; sync                  ' 91    |
            LD      H, (YM_RR_SAV >> 8) ; H point on YM save H  ' 7     | 108 (188)
            JP      state_wD            ; execute               ' 10    |

com_state_wE                            ; 6E                    ' 80
            wait58                      ; sync                  ' 58    |
            LD      H, (YM_RR_SAV >> 8) ; H point on YM save H  ' 7     | 75 (155)
            JP      state_wE            ; execute               ' 10    |

com_state_wF                            ; 6F                    ' 80
            wait35                      ; sync                  ' 35    |
            LD      H, (YM_RR_SAV >> 8) ; H point on YM save H  ' 7     | 42 (122)

state_wF                                ;                       ' 122
            LD      A, (DE)             ; A = state register    ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      L, A                ; HL point on save      ' 4     | 33 (155)
            LD      A, (DE)             ; A = state value       ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      (HL), A             ; write to save         ' 7     |

state_wE
            LD      A, (DE)             ; A = state register    ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      L, A                ; HL point on save      ' 4     | 33 (188)
            LD      A, (DE)             ; A = state value       ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      (HL), A             ; write to save         ' 7     |

state_wD
            LD      A, (DE)             ; A = state register    ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      L, A                ; HL point on save      ' 4     | 33 (221)
            LD      A, (DE)             ; A = state value       ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      (HL), A             ; write to save         ' 7     |

state_wC
            LD      A, (DE)             ; A = state register    ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      L, A                ; HL point on save      ' 4     | 33 (254)
            LD      A, (DE)             ; A = state value       ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      (HL), A             ; write to save         ' 7     |

state_wB
            sampleOutput                ; sample output         ' 36    |
            wait20                      ; wait                  ' 20    | (56)

            LD      A, (DE)             ; A = state register    ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      L, A                ; HL point on save      ' 4     | 33 (89)
            LD      A, (DE)             ; A = state value       ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      (HL), A             ; write to save         ' 7     |

state_wA
            LD      A, (DE)             ; A = state register    ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      L, A                ; HL point on save      ' 4     | 33 (122)
            LD      A, (DE)             ; A = state value       ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      (HL), A             ; write to save         ' 7     |

state_w9
            LD      A, (DE)             ; A = state register    ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      L, A                ; HL point on save      ' 4     | 33 (155)
            LD      A, (DE)             ; A = state value       ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      (HL), A             ; write to save         ' 7     |

state_w8
            LD      A, (DE)             ; A = state register    ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      L, A                ; HL point on save      ' 4     | 33 (188)
            LD      A, (DE)             ; A = state value       ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      (HL), A             ; write to save         ' 7     |

state_w7
            LD      A, (DE)             ; A = state register    ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      L, A                ; HL point on save      ' 4     | 33 (221)
            LD      A, (DE)             ; A = state value       ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      (HL), A             ; write to save         ' 7     |

state_w6
            LD      A, (DE)             ; A = state register    ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      L, A                ; HL point on save      ' 4     | 33 (254)
            LD      A, (DE)             ; A = state value       ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      (HL), A             ; write to save         ' 7     |

state_w5
            sampleOutput                ; sample output         ' 36    |
            wait10                      ; wait                  ' 10    | (46)

            LD      A, (DE)             ; A = state register    ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      L, A                ; HL point on save      ' 4     | 33 (79)
            LD      A, (DE)             ; A = state value       ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      (HL), A             ; write to save         ' 7     |

state_w4
            LD      A, (DE)             ; A = state register    ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      L, A                ; HL point on save      ' 4     | 33 (112)
            LD      A, (DE)             ; A = state value       ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      (HL), A             ; write to save         ' 7     |

state_w3
            LD      A, (DE)             ; A = state register    ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      L, A                ; HL point on save      ' 4     | 33 (145)
            LD      A, (DE)             ; A = state value       ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      (HL), A             ; write to save         ' 7     |

state_w2
            LD      A, (DE)             ; A = state register    ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      L, A                ; HL point on save      ' 4     | 33 (178)
            LD      A, (DE)             ; A = state value       ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      (HL), A             ; write to save         ' 7     |

state_w1
            LD      A, (DE)             ; A = state register    ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      L, A                ; HL point on save      ' 4     | 33 (211)
            LD      A, (DE)             ; A = state value       ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      (HL), A             ; write to save         ' 7     |

state_w0
            LD      A, (DE)             ; A = state register    ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      L, A                ; HL point on save      ' 4     | 33 (244)
            LD      A, (DE)             ; A = state value       ' 7     |
            INC     E                   ; next data             ' 4     |
            LD      (HL), A             ; write to save         ' 7     |

            JP      execute_xgm         ;                       ' 10    | (254)


; NULL command
; ------------

com_null                                ; 01-0F / 60-7C         ' 80
            wait164                     ; sync                  ' 164   |
            JP      execute_xgm         ;                       ' 10    | 174 (254)


; EXTRA FRAME command
; -------------------

com_extra_frm                           ; 7D                            ' 80

            LD      A, $1               ;                               ' 7     |
            LD      (MODIFYING_F), A    ; we are modifying variable     ' 13    | 20 (100)

            LD      A, (PENDING_FRM)    ;                               ' 13    |
            INC     A                   ; force process 1 more frame    ' 4     | 30 (130)
            LD      (PENDING_FRM), A    ;                               ' 13    |

            XOR     A                   ;                               ' 4     |
            LD      (MODIFYING_F), A    ; no more modifying variable    ' 13    | 17 (147)

            LD      HL, ELAPSED         ;                               ' 10    | 10 (157)

            LD      A, (HL)             ;                               ' 7     |
            SUB     A, #1               ;                               ' 7     |
            LD      (HL), A             ;                               ' 7     |
            INC     L                   ;                               ' 4     |
            LD      A, (HL)             ;                               ' 7     |
            SBC     A, #0               ; fix elapsed frame (24 bit)    ' 7     | 71 (228)
            LD      (HL), A             ;                               ' 7     |
            INC     L                   ;                               ' 4     |
            LD      A, (HL)             ;                               ' 7     |
            SBC     A, #0               ;                               ' 7     |
            LD      (HL), A             ;                               ' 7     |

            wait16                      ; sync                          ' 16    | 26 (254)
            JP      execute_xgm         ;                               ' 10    |


; LOOP command
; ------------

com_loop                                ; 7E                        ' 80

            LD      A, (REM_LOOP)       ; A = remaining loop        ' 13    |
            DEC     A                   ; 0 mean infinite loop      ' 4     |
            LD      (REM_LOOP), A       ; A = remaining loop        ' 13    | 40 (120)
            JP      NZ, .continue       ;                           ' 10    |

            LD      HL, COMMAND         ; HL = COMMAND              ' 10    | 25 (145)
            SET     XGM_PAUSE_SFT, (HL) ; request pause/end XGM     ' 15    |

            LD      HL, STATUS          ; HL = STATUS               ' 10    | 25 (170)
            RES     XGM_PLAY_SFT, (HL)  ; clear play status         ' 15    |

            INC     E                   ; next param                ' 4     |
            INC     E                   ;                           ' 4     | 12 (182)
            INC     E                   ;                           ' 4     |

            wait62                      ; sync                      ' 62    |
            JP      execute_xgm         ;                           ' 10    | 72 (254)

.continue
            LD      A, (DE)             ; A = loop addr b7-b0       ' 7     |
            LD      L, A                ; L = loop addr b7-b0       ' 4     |
            INC     E                   ; next param                ' 4     |
            LD      A, (DE)             ; A = loop addr b15-b8      ' 7     | 30 (150)
            LD      H, A                ; HL = loop addr b15-b0     ' 4     |
            INC     E                   ; next param                ' 4     |

            LD      BC, (XGM_ARG_A+0)   ; BC = XGM base addr (ML)   ' 20    |
            ADD     HL, BC              ; HL = XGM base addr + loop ' 11    | 47 (197)
            LD      (XGM_ADDR+0), HL    ; set new XGM addr (ML)     ' 16    |

            LD      A, (DE)             ; A = loop addr b23-b16     ' 7     |
            LD      HL, XGM_ARG_A+2     ; HL point XGM base adr H   ' 10    |
            ADC     (HL)                ; A = XGM base addr + loop  ' 7     | 41 (238)
            INC     E                   ; next param                ' 4     |
            LD      (XGM_ADDR+2), A     ; set new XGM addr (H)      ' 13    |

            XOR     A                   ; force end frame fter loop ' 4     |
            LD      (DE), A             ; after loop taken          ' 7     | 11 (249)

            JP      execute_xgm         ; +5 cycles delay here..    ' 10    | (254+5)


; END XGM command
; ---------------

com_end                                 ; 7F                        ' 80
            LD      HL, COMMAND         ; HL = COMMAND              ' 10    | 25 (105)
            SET     XGM_PAUSE_SFT, (HL) ; request pause/end XGM     ' 15    |

            LD      HL, STATUS          ; HL = STATUS               ' 10    | 25 (130)
            RES     XGM_PLAY_SFT, (HL)  ; clear play status         ' 15    |

            wait114                     ; sync                      ' 114   |
            JP      execute_xgm         ;                           ' 10    | 124 (254)


; $BC+X+Y+Z
do_xgm_again                            ;                           ' 135
            DEC     L                   ; HL point on MODIFYING_F   ' 4     |
            LD      (HL), $0            ; no more modifying         ' 10    | 14 (149)

            wait95                      ; sync                      ' 95    |
            JP      main_loop           ; restart loop (prep xgm)   ' 10    | 105 (254)

; $BC+X+Y+Z
xgm_done                                ;                               ' 90

;    LD  A, (VCOUNTER)
;    LD  (DEBUG_8), A

            LD      HL, MODIFYING_F     ;                               ' 10    |
            LD      (HL), $1            ; we are modifying variable     ' 10    | 24 (114)
            INC     L                   ; HL point on PENDING_FRM       ' 4     |

            DEC     (HL)                ; still have frame to process ? ' 11    |
            JP      NZ, do_xgm_again    ; do XGM process again          ' 10    | 21 (135)

            DEC     L                   ; HL point on MODIFYING_F       ' 4     |
            LD      (HL), $0            ; no more modifying variable    ' 10    | 14 (149)


;    LD  A, (VCOUNTER)
;    LD  (DEBUG_9), A

; execute external command
; ------------------------

; $BC+X+Y+Z
external_com                            ;                           ' 149
            LD      SP, STACK           ; restore stack             ' 10    |
            LD      HL, COMMAND         ; HL point on COMMAND       ' 10    | 20 (159)

.chk_xgm_play
            BIT     XGM_PLAY_SFT, (HL)  ; play XGM command ?        ' 12    |
            JP      Z, .chk_xgm_resume  ;                           ' 10    | 22 (181)

            RES     XGM_PLAY_SFT, (HL)  ; clear command             ' 15    |
            INC     L                   ;                           ' 4     |
            INC     L                   ; HL point on status        ' 4     | 38 (219)
            SET     XGM_PLAY_SFT, (HL)  ; set play status           ' 15    |

            LD      HL, (XGM_ARG_A)     ; set new XGM address       ' 16    |
            LD      (XGM_ADDR), HL      ;                           ' 16    | 58 (277)
            LD      A, (XGM_ARG_A+2)    ;                           ' 13    |
            LD      (XGM_ADDR+2),A      ;                           ' 13    |

            LD      A, (LOOP_ARG)       ; set remaining loop        ' 13    |
            LD      (REM_LOOP),A        ;                           ' 13    | 26 (303)

            LD      HL, #0000           ; clear elapsed frame       ' 10    |
            LD      (ELAPSED), HL       ; (24 bit counter)          ' 16    |
            XOR     A                   ;                           ' 4     | 43 (346)
            LD      (ELAPSED+2), A      ;                           ' 13    |

            LD      HL, COMMAND         ; restore HL                ' 10    |
            JP      external_com_pcm    ; do PCM commands           ' 10    | 20 (254+112)
                                        ; +112 cycles here, ignore

.chk_xgm_resume
            BIT     XGM_RESUME_SFT, (HL)    ; play XGM command ?    ' 12    |
            JP      Z, .chk_xgm_stop        ;                       ' 10    | 22 (203)

            RES     XGM_RESUME_SFT, (HL)    ; clear command         ' 15    |
            INC     L                       ;                       ' 4     |
            INC     L                       ; HL point on status    ' 4     | 38 (241)
            SET     XGM_PLAY_SFT, (HL)      ; set play status       ' 15    |

            LD      DE, YM_RR_SAV       ; DE point on save state    ' 10    |
            LD      SP, STACK           ; set STACK                 ' 10    | 20 (254+7)
                                        ; +7 cycles here, ignore

            CALL    loadState           ; load state                ' 140+  | (140)

            wait94                      ; sync                      ' 94    |
            LD      HL, COMMAND         ; restore HL                ' 10    | 114 (254)
            JP      external_com_pcm    ; do PCM commands           ' 10    |

.chk_xgm_stop
            BIT     XGM_PAUSE_SFT, (HL) ; pause/end XGM command ?   ' 12    |
            JP      Z, .chk_pcm0_pre    ;                           ' 10    | 22 (225)

            RES     XGM_PAUSE_SFT, (HL) ; clear command             ' 15    |
            INC     L                   ;                           ' 4     |
            INC     L                   ; HL point on status        ' 4     | 38 (263)
            RES     XGM_PLAY_SFT, (HL)  ; clear play status         ' 15    |

            LD      DE, YM_RR_OFF       ; DE point on off state     ' 10    |
            LD      SP, STACK           ; set STACK                 ' 10    | 20 (254+29)
                                        ; +29 cycles here, ignore

            CALL    loadState           ; stop music                ' 140+  | (140)

            LD      HL, YMPORT0         ; HL point on YM port0      ' 10    |
            LD      BC, YMPORT1         ; BC point on YM port1      ' 10    | 20 (160)

            LD      (HL), $28           ; set reg num to YM         ' 10    |
            waitYMReadyFast             ; wait YM to be ready       ' 22    | 32 (192)

            XOR     A                   ; A = $00                   ' 4     |
            LD      (BC), A             ; key off - all channel     ' 7     |
            INC     A                   ; A = $01                   ' 4     | 37 (229)
            waitYMReadyFast             ; wait YM to be ready       ' 22    |

            LD      (BC), A             ; key off - all channel     ' 7     |
            waitYMReadyFast             ; wait YM to be ready       ' 22    | 29 (254+4)

            sampleOutputSafe            ; *** sample output ****    ' 46    | (46+4)

            waitYMReadyFast             ; wait YM to be ready       ' 22    |
            LD      (HL), $28           ; set reg num to YM         ' 10    |
            LD      A, $02              ; A = $02                   ' 7     | 61 (111)
            waitYMReadyFast             ; wait YM to be ready       ' 22    |

            LD      (BC), A             ; key off - all channel     ' 7     |
            ADD     $2                  ; A = $04                   ' 7     | 36 (147)
            waitYMReadyFast             ; wait YM to be ready       ' 22    |

            LD      (BC), A             ; key off - all channel     ' 7     |
            INC     A                   ; A = $05                   ' 4     | 33 (180)
            waitYMReadyFast             ; wait YM to be ready       ' 22    |

            LD      (BC), A             ; key off - all channel     ' 7     |
            INC     A                   ; A = $06                   ' 4     | 33 (213)
            waitYMReadyFast             ; wait YM to be ready       ' 22    |

            LD      (BC), A             ; key off - all channel     ' 7     |
            waitYMReadyFast             ; wait YM to be ready       ' 22    | 39 (252)
            LD      (HL), $2A           ; restore DAC write         ' 10    |

            LD      HL, COMMAND         ; restore HL                ' 10    |
            JP      external_com_pcm    ; continue                  ' 10    | 20 (254+18)
                                        ; +18 cycles here, ignore

.chk_pcm0_pre                           ;                           ' 225
            LD      HL, COMMAND         ; restore HL                ' 10    |
            wait19                      ; sync                      ' 19    | 29 (254)

; $BD+X+Y+Z
external_com_pcm
            sampleOutput                ; *** sample output ****    ' 36    | (36)

.chk_pcm0
            BIT     CH0_SFT, (HL)       ; play PCM0 command ?       ' 12    |
            JP      Z, .chk_pcm1        ;                           ' 10    | 22 (58)

            RES     CH0_SFT, (HL)       ; clear command             ' 15    | (73)

            handlePCMCommand 0          ; handle play PCM command   ' 157   | 167 (240)
            LD      HL, COMMAND         ; restore HL                ' 10    |

            wait14                      ; sync                      ' 14    | (254)

            sampleOutput                ; *** sample output ****    ' 36    | (36)

            wait22                      ; sync                      ' 22    | (58)

.chk_pcm1
            BIT     CH1_SFT, (HL)       ; play PCM1 command ?       ' 12    |
            JP      Z, .chk_pcm2        ;                           ' 10    | 22 (80)

            RES     CH1_SFT, (HL)       ; clear command             ' 15    | (95)

            handlePCMCommand 1          ; handle play PCM command   ' 157   | (254-2)

            sampleOutput                ; *** sample output ****    ' 36    | (36-2)

            wait36                      ; sync                      ' 36    | 46 (80)
            LD      HL, COMMAND         ; restore HL                ' 10    |

.chk_pcm2
            BIT     CH2_SFT, (HL)       ; play PCM2 command ?       ' 12    |
            JP      Z, .chk_pcm3        ;                           ' 10    | 22 (102)

            RES     CH2_SFT, (HL)       ; clear command             ' 15    | (117)

            handlePCMCommand 2          ; handle play PCM command   ' 157   | (254+20)

            sampleOutput                ; *** sample output ****    ' 36    | (36+20)

            wait36                      ; sync                      ' 36    | 46 (102)
            LD      HL, COMMAND         ; restore HL                ' 10    |

.chk_pcm3
            BIT     CH3_SFT, (HL)       ; play PCM3 command ?       ' 12    |
            JP      Z, ext_com_done     ;                           ' 10    | 22 (124)

            RES     CH3_SFT, (HL)       ; clear command             ' 15    | (139)

            handlePCMCommand 3          ; handle play PCM command   ' 157   | (254+42)

            sampleOutput                ; *** sample output ****    ' 36    | (36+42)

            wait46                      ; sync                      ' 46    | (124)

; $BD+X+Y+Z
ext_com_done                                ;                           ' 124
            LD      BC, STATUS              ; BC point on STATUS        ' 10    |
            LD      A, (BC)                 ; A = STATUS                ' 7     | 24 (148)
            AND     $F0                     ; clear PCM play status     ' 7     |

            LD      HL, (ID_TABLE+0)        ; HL = null PCM addr        ' 16    |
            LD      DE, (PCM_ADDR+(0*8))    ; DE = PCM ch0 addr         ' 20    |
            SBC     HL, DE                  ; HL == DE ?                ' 15    | 63 (211)
            JR      Z, .ch0_silent          ; ch0 is not playing        ' 12    |

            OR      A, $01                  ; set play status for ch0   ' +2

.ch0_silent
            EX      AF, AF'                 ; preserve AF               ' 4     |
            wait35                          ; sync                      ' 35    | 39 (254-4)

; $BE+X+Y+Z
            sampleOutput                    ; sample output             ' 36-4  | (36)
            EX      AF, AF'                 ; restore AF                ' 4     |

            LD      HL, (ID_TABLE+0)        ; HL = null PCM addr        ' 16    |
            LD      DE, (PCM_ADDR+(1*8))    ; DE = PCM ch1 addr         ' 20    |
            SBC     HL, DE                  ; HL == DE ?                ' 15    | 63 (99)
            JR      Z, .ch1_silent          ; ch1 is not playing        ' 12    |

            OR      A, $02                  ; set play status for ch1   ' +2

.ch1_silent
            LD      HL, (ID_TABLE+0)        ; HL = null PCM addr        ' 16    |
            LD      DE, (PCM_ADDR+(2*8))    ; DE = PCM ch2 addr         ' 20    |
            SBC     HL, DE                  ; HL == DE ?                ' 15    | 63 (162)
            JR      Z, .ch2_silent          ; ch2 is not playing        ' 12    |

            OR      A, $04                  ; set play status for ch2   ' +2

.ch2_silent
            LD      HL, (ID_TABLE+0)        ; HL = null PCM addr        ' 16    |
            LD      DE, (PCM_ADDR+(3*8))    ; DE = PCM ch3 addr         ' 20    |
            SBC     HL, DE                  ; HL == DE ?                ' 15    | 63 (225)
            JR      Z, .ch3_silent          ; ch3 is not playing        ' 12    |

            OR      A, $08                  ; set play status for ch3   ' +2

.ch3_silent
            LD      (BC), A                 ; set new status            ' 7     | (229)

            LD      A, (PROTECT_ARG)        ; get BUS protect state     ' 13    |
            OR      A                       ; no protecting ?           ' 4     | 27 (254+2)
            JP      Z, main_loop            ; process next frame        ' 10    |
                                            ; +2 cycles here, ignore...

; frame done
;
; 1 frame of PCM sample (256 bytes) is ~287 lines.
;
; NTSC: we should be <= 0xE8 to respect frame time here and we need to update PCM buffer 0.9 time per frame
; so we have a free PCM mix frame from time to time.
; Median (X+Y+Z) should be < 0x2A (< 42) plus some lines from the free PCM mix
;
; PAL: we should be <= 0118 to respect frame time here but we need to update PCM buffer 1.1 time per frame
; so we have a penalty PCM mix frame from time to time.
; Median (X+Y+Z) should be < 0x5A (< 90) minus some lines for the extra PCM mix
; -------------------------------------------------------------------------------------


;    LD  A, (VCOUNTER)
;    LD  (DEBUG_A), A

; BUS protection wait (to avoid BUS contention with DMA)
;
; $BF+X+Y+Z

bus_protect_wait
            sampleOutput                ; *** sample output *** ' 36    | (36)

            wait105                     ; sync                  ' 105   | (141)

            LD      A, (PROTECT_ARG)    ; get BUS protect state ' 13    |
            OR      A                   ; no more protecting ?  ' 4     | 27 (168)
            JP      Z, .continue        ; continue              ' 10    |

            LD      HL, (IDLE_LOOP)     ;                       ' 16    |
            INC     HL                  ; increment idle loop   ' 6     | 38 (206)
            LD      (IDLE_LOOP), HL     ;                       ' 16    |

            LD      HL, (WAIT_LOOP)     ;                       ' 16    |
            INC     HL                  ; increment wait loop   ' 6     | 38 (244)
            LD      (WAIT_LOOP), HL     ;                       ' 16    |

            JP      bus_protect_wait    ; wait until bus is ok  ' 10    | (254)

.continue                               ;                       ' 168

;    LD  A, (VCOUNTER)
;    LD  (DEBUG_B), A

            wait76                      ; sync                  ' 76    |
            JP      main_loop           ; process next frame    ' 10    | 86 (254)



; ##############################  functions  ################################

            INCLUDE "z80_fct.i80"   ; basic functions


; preparePCMBuffering
; -------------------
; PCM source address (bit 8-23) ->  HL  -> PCM write buffer
; ?  ->  DE  -> PCM source (ROM)
;
; prepare for PCM buffering (set bank to PCM source)
; 159+17=176 cycles

preparePCMBuffering

;            LD      HL, (PCM_ADDR+(ch*8))   ; HL = sample addr (HM) ' 16    | (16)

            LD      A, L                ; A = bit 8-15          ' 4     |
            RLA                         ; C flag = bit 15       ' 4     |
            LD      A, H                ; A = bit 16-23         ' 4     | (16)
            RLA                         ; A = bit 15-22         ' 4     |

            setBank_DE                  ; set bank              ' 105   | (137)

            LD      D, L                ;                       ' 4     |
            SET     7, D                ; DE = PCM addr bank    ' 8     | 12 (133)

            LD      HL, (WRITEBUF)      ; HL = write buffer     ' 16    | (149)

            RET                         ; done                  ' 10    | (159)





; loadState
; ---------
;     ?       ->  HL  -> ?
;     ?       ->  BC  -> ?
; reg source  ->  DE  -> ?
;
; load the YM and PSG state
; = 8 samples + 140 cycles

loadState

            sampleOutput                ; *** sample output ****    ' 36    | (36)

            LD      HL, YMPORT0         ; HL point on YM port0      ' 10    |
            LD      BC, YMPORT1         ; BC point on YM port1      ' 10    | 20 (56)

            CALL    loadYMState         ; load YM state             ' 188+  | (244)

            LD      HL, YMPORT2         ; HL point on YM port2      ' 10    |
            LD      BC, YMPORT3         ; BC point on YM port3      ' 10    | 20 (254+10)

            sampleOutputSafe            ; *** sample output ****    ' 46    | (46+10)

            CALL    loadYMState         ; load YM state             ' 188+  | (244)

            LD      HL, PSGPORT         ; HL point on PSG           ' 10    | (254)

            sampleOutput                ; *** sample output ****    ' 36    | (36)

            JP      loadPSGState        ; load PSG state            ' 10+94 | (140)


; loadYMState
; -----------
; YMPORT0/2   ->  HL
; YMPORT1/3   ->  BC
; reg source  ->  DE  -> ?
;
; load the YM RR state
; = 4 samples (244 cycles)

loadYMState                             ;                           ' 56

            waitYMReady                 ; wait YM to be ready       ' 30    |
            LD      (HL), $80           ; set reg num to YM         ' 10    |
            LD      A, (DE)             ; get saved value           ' 7     |
            INC     E                   ; next                      ' 4     | 62 (118)
            wait4                       ; wait YM to be ready       ' 4     |
            LD      (BC), A             ; restore state             ' 7     |

            waitYMReady                 ; wait YM to be ready       ' 30    |
            LD      (HL), $81           ; set reg num to YM         ' 10    |
            LD      A, (DE)             ; get saved value           ' 7     | 62 (180)
            INC     E                   ; next                      ' 4     |
            wait4                       ; wait YM to be ready       ' 4     |
            LD      (BC), A             ; restore state             ' 7     |

            waitYMReady                 ; wait YM to be ready       ' 30    |
            LD      (HL), $82           ; set reg num to YM         ' 10    |
            LD      A, (DE)             ; get saved value           ' 7     | 62 (242)
            INC     E                   ; next                      ' 4     |
            wait4                       ; wait YM to be ready       ' 4     |
            LD      (BC), A             ; restore state             ' 7     |

            EXX                         ;                           ' 4     | (246)

.wait1
            BIT     7, (HL)             ; test YM ready bit         ' 12    |
            JP      NZ, .wait1          ; wait while busy           ' 10    | 22 (254+14)

            LD      (HL), $2A           ;                           ' 10    |
            LD      A, (BC)             ;                           ' 7     |
            INC     BC                  ; *** sample output ****    ' 6     | 38 (52)
            RES     2, B                ;                           ' 8     |
            LD      (DE), A             ;                           ' 7     |

.wait2
            BIT     7, (HL)             ; test YM ready bit         ' 12    |
            JP      NZ, .wait2          ; wait while busy           ' 10    | 22 (74)

            EXX                         ;                           ' 4     | (78)

            LD      (HL), $84           ; set reg num to YM         ' 10    |
            LD      A, (DE)             ; get saved value           ' 7     |
            INC     E                   ; next                      ' 4     | 32 (110)
            wait4                       ; wait YM to be ready       ' 4     |
            LD      (BC), A             ; restore state             ' 7     |

            waitYMReady                 ; wait YM to be ready       ' 30    |
            LD      (HL), $85           ; set reg num to YM         ' 10    |
            LD      A, (DE)             ; get saved value           ' 7     | 62 (172)
            INC     E                   ; next                      ' 4     |
            wait4                       ; wait YM to be ready       ' 4     |
            LD      (BC), A             ; restore state             ' 7     |

            waitYMReady                 ; wait YM to be ready       ' 30    |
            LD      (HL), $86           ; set reg num to YM         ' 10    |
            LD      A, (DE)             ; get saved value           ' 7     | 62 (234)
            INC     E                   ; next                      ' 4     |
            wait4                       ; wait YM to be ready       ' 4     |
            LD      (BC), A             ; restore state             ' 7     |

            EXX                         ;                           ' 4     | (238)

.wait3
            BIT     7, (HL)             ; test YM ready bit         ' 12    |
            JP      NZ, .wait3          ; wait while busy           ' 10    | 22 (254+6)

            LD      (HL), $2A           ;                           ' 10    |
            LD      A, (BC)             ;                           ' 7     |
            INC     BC                  ; *** sample output ****    ' 6     | 38 (44)
            RES     2, B                ;                           ' 8     |
            LD      (DE), A             ;                           ' 7     |

.wait4
            BIT     7, (HL)             ; test YM ready bit         ' 12    |
            JP      NZ, .wait4          ; wait while busy           ' 10    | 22 (66)

            EXX                         ;                           ' 4     | (78)
            wait8                       ; sync                      ' 8     |

            LD      (HL), $88           ; set reg num to YM         ' 10    |
            LD      A, (DE)             ; get saved value           ' 7     |
            INC     E                   ; next                      ' 4     | 32 (110)
            wait4                       ; wait YM to be ready       ' 4     |
            LD      (BC), A             ; restore state             ' 7     |

            waitYMReady                 ; wait YM to be ready       ' 30    |
            LD      (HL), $89           ; set reg num to YM         ' 10    |
            LD      A, (DE)             ; get saved value           ' 7     | 62 (172)
            INC     E                   ; next                      ' 4     |
            wait4                       ; wait YM to be ready       ' 4     |
            LD      (BC), A             ; restore state             ' 7     |

            waitYMReady                 ; wait YM to be ready       ' 30    |
            LD      (HL), $8A           ; set reg num to YM         ' 10    |
            LD      A, (DE)             ; get saved value           ' 7     | 62 (234)
            INC     E                   ; next                      ' 4     |
            wait4                       ; wait YM to be ready       ' 4     |
            LD      (BC), A             ; restore state             ' 7     |

            EXX                         ;                           ' 4     | (238)

.wait5
            BIT     7, (HL)             ; test YM ready bit         ' 12    |
            JP      NZ, .wait5          ; wait while busy           ' 10    | 22 (254+6)

            LD      (HL), $2A           ;                           ' 10    |
            LD      A, (BC)             ;                           ' 7     |
            INC     BC                  ; *** sample output ****    ' 6     | 38 (44)
            RES     2, B                ;                           ' 8     |
            LD      (DE), A             ;                           ' 7     |

.wait6
            BIT     7, (HL)             ; test YM ready bit         ' 12    |
            JP      NZ, .wait6          ; wait while busy           ' 10    | 22 (66)

            EXX                         ;                           ' 4     | (78)
            wait8                       ; sync                      ' 8     |

            LD      (HL), $8C           ; set reg num to YM         ' 10    |
            LD      A, (DE)             ; get saved value           ' 7     |
            INC     E                   ; next                      ' 4     | 32 (110)
            wait4                       ; wait YM to be ready       ' 4     |
            LD      (BC), A             ; restore state             ' 7     |

            waitYMReady                 ; wait YM to be ready       ' 30    |
            LD      (HL), $8D           ; set reg num to YM         ' 10    |
            LD      A, (DE)             ; get saved value           ' 7     | 62 (172)
            INC     E                   ; next                      ' 4     |
            wait4                       ; wait YM to be ready       ' 4     |
            LD      (BC), A             ; restore state             ' 7     |

            waitYMReady                 ; wait YM to be ready       ' 30    |
            LD      (HL), $8E           ; set reg num to YM         ' 10    |
            LD      A, (DE)             ; get saved value           ' 7     | 62 (234)
            INC     E                   ; next                      ' 4     |
            wait4                       ; wait YM to be ready       ' 4     |
            LD      (BC), A             ; restore state             ' 7     |

            RET                         ; done                      ' 10    | (244)


; loadPSGState
; ------------
; PSGPORT     ->  HL
; reg source  ->  DE  -> ?
;
; load the PSG env state
; 94 cycles

loadPSGState

            LD      A, (DE)             ; get saved value           ' 7     |
            INC     E                   ; next                      ' 4     | (21)
            LD      (HL), A             ; PSG restore channel 0 env ' 10    |

            LD      A, (DE)             ; get saved value           ' 7     |
            INC     E                   ; next                      ' 4     | 21 (42)
            LD      (HL), A             ; PSG restore channel 1 env ' 10    |

            LD      A, (DE)             ; get saved value           ' 7     |
            INC     E                   ; next                      ' 4     | 21 (63)
            LD      (HL), A             ; PSG restore channel 2 env ' 10    |

            LD      A, (DE)             ; get saved value           ' 7     |
            INC     E                   ; next                      ' 4     | 21 (84)
            LD      (HL), A             ; PSG restore channel 3 env ' 10    |

            RET                         ; done                      ' 10    | (94)


; ##############################  jump table  ################################

            BLOCK   $1600-$

            DW      com_next_frame                                                                  ; 00

            DW      com_null, com_null, com_null                                                    ; 01-03
            DW      com_null, com_null, com_null, com_null                                          ; 04-07
            DW      com_null, com_null, com_null, com_null                                          ; 08-0B
            DW      com_null, com_null, com_null, com_null                                          ; 0C-0F

            DW      com_psg_tone_w0, com_psg_tone_w1, com_psg_tone_w2, com_psg_tone_w3              ; 10-13
            DW      com_psg_tone_w4, com_psg_tone_w5, com_psg_tone_w6, com_psg_tone_w7              ; 14-17
            DW      com_psg_env_w0, com_psg_env_w1, com_psg_env_w2, com_psg_env_w3                  ; 18-1B
            DW      com_null, com_null, com_null, com_null                                          ; 1C-1F

            DW      com_ym_port0_w0, com_ym_port0_w1, com_ym_port0_w2, com_ym_port0_w3              ; 20-23
            DW      com_ym_port0_w4, com_ym_port0_w5, com_ym_port0_w6, com_ym_port0_w7              ; 24-27
            DW      com_ym_port0_w8, com_ym_port0_w9, com_ym_port0_wA, com_ym_port0_wB              ; 28-2B
            DW      com_ym_port0_wC, com_ym_port0_wD, com_ym_port0_wE, com_ym_port0_wF              ; 2C-2F

            DW      com_ym_port2_w0, com_ym_port2_w1, com_ym_port2_w2, com_ym_port2_w3              ; 30-33
            DW      com_ym_port2_w4, com_ym_port2_w5, com_ym_port2_w6, com_ym_port2_w7              ; 34-37
            DW      com_ym_port2_w8, com_ym_port2_w9, com_ym_port2_wA, com_ym_port2_wB              ; 38-3B
            DW      com_ym_port2_wC, com_ym_port2_wD, com_ym_port2_wE, com_ym_port2_wF              ; 3C-3F

            DW      com_ym_key_w0, com_ym_key_w1, com_ym_key_w2, com_ym_key_w3                      ; 40-43
            DW      com_ym_key_w4, com_ym_key_w5, com_null, com_null                                ; 44-47
            DW      com_null, com_null, com_null, com_null                                          ; 48-4B
            DW      com_null, com_null, com_null, com_null                                          ; 4C-4F

            DW      com_pcm_p0_ch0, com_pcm_p0_ch1, com_pcm_p0_ch2, com_pcm_p0_ch3                  ; 50-53
            DW      com_pcm_p1_ch0, com_pcm_p1_ch1, com_pcm_p1_ch2, com_pcm_p1_ch3                  ; 54-57
            DW      com_pcm_p2_ch0, com_pcm_p2_ch1, com_pcm_p2_ch2, com_pcm_p2_ch3                  ; 58-5B
            DW      com_pcm_p3_ch0, com_pcm_p3_ch1, com_pcm_p3_ch2, com_pcm_p3_ch3                  ; 5C-5F

            DW      com_state_w0, com_state_w1, com_state_w2, com_state_w3                          ; 60-63
            DW      com_state_w4, com_state_w5, com_state_w6, com_state_w7                          ; 64-67
            DW      com_state_w8, com_state_w9, com_state_wA, com_state_wB                          ; 68-6B
            DW      com_state_wC, com_state_wD, com_state_wE, com_state_wF                          ; 6C-6F

            DW      com_null, com_null, com_null, com_null                                          ; 70-74
            DW      com_null, com_null, com_null, com_null                                          ; 74-77
            DW      com_null, com_null, com_null, com_null                                          ; 78-7B
            DW      com_null                                                                        ; 7C

            DW      com_extra_frm                                                                   ; 7D
            DW      com_loop                                                                        ; 7E
            DW      com_end                                                                         ; 7F


            END
